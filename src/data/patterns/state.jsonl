{"instruction":"Create a Svelte 5 component demonstrating $state: The rune allows you to create which means that your UI when it changes.","input":"The rune allows you to create which means that your UI when it changes.","output":"<script>\nlet count = $state(0);\n</script>\n\n<button onclick={() => count++}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $state: If is used with an array or a simple object, the result is a deeply reactive .","input":"If is used with an array or a simple object, the result is a deeply reactive . allow Svelte to run code when you read or write properties, including via methods like triggering granular updates. State is proxified recursively until Svelte finds something other than an array or simple object. In a case like this.","output":"let todos = $state([\n  { done: false, text: 'add more todos' }\n]);"}
{"instruction":"Create a Svelte 5 component demonstrating $state: ...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property:","input":"...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property:","output":"let todos = [{ done: false, text: 'add more todos' }];\ntodos[0].done = !todos[0].done;"}
{"instruction":"Create a Svelte 5 component demonstrating $state: If you push a new object to the array, it will also be proxified:","input":"If you push a new object to the array, it will also be proxified:","output":"let todos = [{ done: false, text: 'add more todos' }];\ntodos.push({ done: false, text: 'eat lunch' });"}
{"instruction":"Create a Svelte 5 component demonstrating $state: Note that if you destructure a reactive value, the references are not reactive â€” as in normal JavaScript, they are evaluated at the point of destructuring:","input":"Note that if you destructure a reactive value, the references are not reactive â€” as in normal JavaScript, they are evaluated at the point of destructuring:","output":"let todos = [{ done: false, text: 'add more todos' }];\nlet { done, text } = todos[0];\n\n// this will not affect the value of `done`\ntodos[0].done = !todos[0].done;"}
{"instruction":"Create a Svelte 5 component demonstrating $state: You can also use in class fields (whether public or private):","input":"You can also use in class fields (whether public or private):","output":"class Todo {\n  done = $state(false);\n  text = $state();\n\n  constructor(text) {\n    this.text = text;\n  }\n\n  reset() {\n    this.text = '';\n    this.done = false;\n  }\n}"}
{"instruction":"Create a Svelte 5 component demonstrating $state: This won't work, because inside the method will be the rather than the :","input":"This won't work, because inside the method will be the rather than the :","output":"<button onclick={todo.reset}>\n  reset\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $state: You can either use an inline function...","input":"You can either use an inline function...","output":"<button onclick={() => todo.reset()}>\n  reset\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $state: ...or use an arrow function in the class definition:","input":"...or use an arrow function in the class definition:","output":"class Todo {\n  done = $state(false);\n  text = $state();\n\n  constructor(text) {\n    this.text = text;\n  }\n\n  reset = () => {\n    this.text = '';\n    this.done = false;\n  }\n}"}
{"instruction":"Create a Svelte 5 component demonstrating $state: In cases where you don't want objects and arrays to be deeply reactive you can use .","input":"In cases where you don't want objects and arrays to be deeply reactive you can use . State declared with cannot be mutated; it can only be . In other words, rather than assigning to a property of an object, or using an array method like replace the object or array altogether if you'd like to update it:","output":"let person = $state.raw({ name: 'Heraclitus', age: 49 });\n\n// this will have no effect\nperson.age += 1;\n\n// this will work, because we're creating a new person\nperson = { name: 'Heraclitus', age: 50 };"}
{"instruction":"Create a Svelte 5 component demonstrating $state: To take a static snapshot of a deeply reactive proxy, use :","input":"To take a static snapshot of a deeply reactive proxy, use :","output":"<script>\nlet counter = $state({ count: 0 });\n\nfunction onclick() {\n  // Will log `{ count: ... }` rather than `Proxy { ... }`\n  console.log($state.snapshot(counter));\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Derived state is declared with the rune:","input":"Derived state is declared with the rune:","output":"<script>\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n</script>\n\n<button onclick={() => count++}>\n  {doubled}\n</button>\n\n<p>{count} doubled is {doubled}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Sometimes you need to create complex derivations that don't fit inside a short expression.","input":"Sometimes you need to create complex derivations that don't fit inside a short expression. In these cases, you can use which accepts a function as its argument.","output":"<script>\nlet numbers = $state([1, 2, 3]);\n\nlet total = $derived.by(() => {\n  let total = 0;\n  for (const n of numbers) {\n    total += n;\n  }\n  return total;\n});\n</script>\n\n<button onclick={() => numbers.push(numbers.length + 1)}>\n  {numbers.join(' + ')} = {total}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with ).","input":"Derived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with ). This can be useful for things like where a value is derived from the 'source of truth' (such as data from your server) but you'd like to show immediate feedback to the user:","output":"<script>\nlet { post, like } = $props();\n\nlet likes = $derived(post.likes);\n\nasync function onclick() {\n  // increment the `likes` count immediately...\n  likes += 1;\n\n  // and tell the server, which will eventually update `post`\n  try {\n    await like();\n  } catch {\n    // failed! roll back the change\n    likes -= 1;\n  }\n}\n</script>\n\n<button {onclick}>ðŸ§¡ {likes}</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: ...you can change (or to) properties of and it will affect the underlying array.","input":"...you can change (or to) properties of and it will affect the underlying array. If was reactive, mutating would have no effect.","output":"let items = $state([...]);\nlet index = $state(0);\nlet selected = $derived(items[index]);"}
{"instruction":"Create a Svelte 5 component demonstrating $derived: Svelte uses something called â€” when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the 'push'), but derived values are not re-evaluated until they are actually read (the 'pull').","input":"Svelte uses something called â€” when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the 'push'), but derived values are not re-evaluated until they are actually read (the 'pull'). If the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when changes, not when changes, even though depends on :","output":"<script>\nlet count = $state(0);\nlet large = $derived(count > 10);\n</script>\n\n<button onclick={() => count++}>\n  {large}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: References to a prop inside a component update when the prop itself updates â€” when changes in it will also change inside .","input":"References to a prop inside a component update when the prop itself updates â€” when changes in it will also change inside . But the child component is able to temporarily override the prop value, which can be useful for unsaved ephemeral state ( ):","output":"<!file: App.svelte>\n<script>\nimport Child from './Child.svelte';\n\nlet count = $state(0);\n</script>\n\n<button onclick={() => (count += 1)}>\n  clicks (parent): {count}\n</button>\n\n<Child {count} />"}
{"instruction":"Create a Svelte 5 component demonstrating $props: If the prop is a reactive state proxy, however, then mutations have an effect but you will see an warning, because the component is mutating state that does not 'belong' to it ( ):","input":"If the prop is a reactive state proxy, however, then mutations have an effect but you will see an warning, because the component is mutating state that does not 'belong' to it ( ):","output":"<!file: App.svelte>\n<script>\nimport Child from './Child.svelte';\n\nlet object = $state({count: 0});\n</script>\n\n<Child {object} />"}
{"instruction":"Create a Svelte 5 component demonstrating $props: The fallback value of a prop not declared with is left untouched â€” it is not turned into a reactive state proxy â€” meaning mutations will not cause updates ( )","input":"The fallback value of a prop not declared with is left untouched â€” it is not turned into a reactive state proxy â€” meaning mutations will not cause updates ( )","output":"<!file: Child.svelte>\n<script>\nlet { object = { count: 0 } } = $props();\n</script>\n\n<button onclick={() => {\n  // has no effect if the fallback value is used\n  object.count += 1\n}}>\n  clicks: {object.count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $bindable: Now, a component that uses can add the directive ( ):","input":"Now, a component that uses can add the directive ( ):","output":"<script>\nimport FancyInput from './FancyInput.svelte';\n\nlet message = $state('hello');\n</script>\n\n<FancyInput bind:value={message} />\n<p>{message}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $inspect: The rune is roughly equivalent to with the exception that it will re-run whenever its argument changes.","input":"The rune is roughly equivalent to with the exception that it will re-run whenever its argument changes. tracks reactive state deeply, meaning that updating something inside an object or array using fine-grained reactivity will cause it to re-fire ( ):","output":"<script>\nlet count = $state(0);\nlet message = $state('hello');\n\n$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />"}
{"instruction":"Create a Svelte 5 component demonstrating $inspect: returns a property which you can invoke with a callback, which will then be invoked instead of .","input":"returns a property which you can invoke with a callback, which will then be invoked instead of . The first argument to the callback is either or subsequent arguments are the values passed to ( ):","output":"<script>\nlet count = $state(0);\n\n$inspect(count).with((type, count) => {\n  if (type === 'update') {\n    debugger; // or `console.trace`, or whatever you want\n  }\n});\n</script>\n\n<button onclick={() => count++}>Increment</button>"}
{"instruction":"Write Svelte 5 code for $host.","input":"","output":"<script>\nimport './Stepper.svelte';\n\nlet count = $state(0);\n</script>\n\n<my-stepper\n  ondecrement={() => count -= 1}\n  onincrement={() => count += 1}\n></my-stepper>\n\n<p>count: {count}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: A directive on an element binds the input's property:","input":"A directive on an element binds the input's property:","output":"<script>\nlet message = $state('hello');\n</script>\n\n<input bind:value={message} />\n<p>{message}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: In the case of a numeric input ( or ) the value will be coerced to a number ( ):","input":"In the case of a numeric input ( or ) the value will be coerced to a number ( ):","output":"<script>\nlet a = $state(1);\nlet b = $state(2);\n</script>\n\n<label>\n  <input type=\"number\" bind:value={a} min=\"0\" max=\"10\" />\n  <input type=\"range\" bind:value={a} min=\"0\" max=\"10\" />\n</label>\n\n<label>\n  <input type=\"number\" bind:value={b} min=\"0\" max=\"10\" />\n  <input type=\"range\" bind:value={b} min=\"0\" max=\"10\" />\n</label>\n\n<p>{a} + {b} = {a + b}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Since 5.6.0, if an has a and is part of a form, it will revert to that value instead of the empty string when the form is reset.","input":"Since 5.6.0, if an has a and is part of a form, it will revert to that value instead of the empty string when the form is reset. Note that for the initial render the value of the binding takes precedence unless it is or .","output":"<script>\n  let value = $state('');\n</script>\n\n<form>\n  <input bind:value defaultValue=\"not the empty string\">\n  <input type=\"reset\" value=\"Reset\">\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Since 5.6.0, if an has a attribute and is part of a form, it will revert to that value instead of when the form is reset.","input":"Since 5.6.0, if an has a attribute and is part of a form, it will revert to that value instead of when the form is reset. Note that for the initial render the value of the binding takes precedence unless it is or .","output":"<script>\n  let checked = $state(true);\n</script>\n\n<form>\n  <input type=\"checkbox\" bind:checked defaultChecked={true}>\n  <input type=\"reset\" value=\"Reset\">\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Inputs that work together can use .","input":"Inputs that work together can use .","output":"<script>\nlet tortilla = $state('Plain');\n/** @type {Array<string>} */\nlet fillings = $state([]);\n</script>\n\n<input type=\"radio\" bind:group={tortilla} value=\"Plain\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Whole wheat\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Spinach\" />\n\n<input type=\"checkbox\" bind:group={fillings} value=\"Rice\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Beans\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Cheese\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Guac (extra)\" />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: On elements with you can use to get the .","input":"On elements with you can use to get the . When you want to update the files programmatically, you always need to use a object. Currently objects cannot be constructed directly, so you need to create a new object and get from there.","output":"<script>\nlet files = $state();\n\nfunction clear() {\n  files = new DataTransfer().files; // null or undefined does not work\n}\n</script>\n\n<label for=\"avatar\">Upload a picture:</label>\n\n<input\n  accept=\"image/png, image/jpeg\"\n  bind:files\n  id=\"avatar\"\n  name=\"avatar\"\n  type=\"file\"\n/>\n\n<button onclick={clear}>clear</button>"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: A is triggered by an element entering or leaving the DOM as a result of a state change.","input":"A is triggered by an element entering or leaving the DOM as a result of a state change. When a block (such as an block) is transitioning out, all elements inside it, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed. The directive indicates a transition, which means it can be smoothly reversed while the transition is in progress.","output":"<script>\nimport { fade } from 'svelte/transition';\n\nlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>toggle</button>\n\n{#if visible}\n  <divtransition:fade>fades in and out</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating in: and out:: The and directives are identical to except that the resulting transitions are not bidirectional â€” an transition will continue to 'play' alongside the transition, rather than reversing, if the block is outroed while the transition is in progress.","input":"The and directives are identical to except that the resulting transitions are not bidirectional â€” an transition will continue to 'play' alongside the transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.","output":"<script>\nimport { fade, fly } from 'svelte/transition';\n\nlet visible = $state(false);\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={visible}>\n  visible\n</label>\n\n{#if visible}\n  <div in:fly={{ y: 200 }} out:fade>flies in, fades out</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating class: The user of this component has the same flexibility to use a mixture of objects, arrays and strings:","input":"The user of this component has the same flexibility to use a mixture of objects, arrays and strings:","output":"<!file: App.svelte>\n<script>\nimport Button from './Button.svelte';\n\nlet useTailwind = $state(false);\n</script>\n\n<Button\n  onclick={() => useTailwind = true}\n  class={{ 'bg-blue-700 sm:w-1/2': useTailwind }}\n>\n  Accept the inevitability of Tailwind\n</Button>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:boundary>: ...or using and outside the boundary itself:","input":"...or using and outside the boundary itself:","output":"<script>\nlet error = $state(null);\nlet reset = $state(() => {});\n\nfunction onerror(e, r) {\n  error = e;\n  reset = r;\n}\n</script>\n\n<svelte:boundary {onerror}>\n  <FlakyComponent />\n</svelte:boundary>\n\n{#if error}\n  <button onclick={() => {\n    error = null;\n    reset();\n  }}>\n    oops! try again\n  </button>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:element>: The element lets you render an element that is unknown at author time, for example because it comes from a CMS.","input":"The element lets you render an element that is unknown at author time, for example because it comes from a CMS. Any properties and event listeners present will be applied to the element. The only supported binding is since Svelte's built-in bindings do not work with generic elements. If has a nullish value, the element and its children will not be rendered. If is the name of a (e.g., ) and has child elements, a runtime error will be thrown in development mode:","output":"<script>\nlet tag = $state('hr');\n</script>\n\n<svelte:element this={tag}>\n  This text cannot appear inside an hr element\n</svelte:element>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: You can store reactive state in context ( )...","input":"You can store reactive state in context ( )...","output":"<script>\nimport { setContext } from 'svelte';\nimport Child from './Child.svelte';\n\nlet counter = $state({ count: 0 });\nsetContext('counter', counter);\n</script>\n\n<button onclick={() => counter.count += 1}>\n  increment\n</button>\n\n<Child />\n<Child />\n<Child />"}
{"instruction":"Create a Svelte 5 component demonstrating Reactive let/var declarations: In runes mode, reactive state is explicitly declared with the .","input":"In runes mode, reactive state is explicitly declared with the . In legacy mode, variables declared at the top level of a component are automatically considered . Reassigning or mutating these variables ( or ) will cause the UI to update.","output":"<script>\nlet count = 0;\n</script>\n\n<button on:click={() => count += 1}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Reactive $: statements: In runes mode, reactions to state updates are handled with the and runes.","input":"In runes mode, reactions to state updates are handled with the and runes. In legacy mode, any top-level statement (i.e. not inside a block or a function) can be made reactive by prefixing it with a . These statements run after other code in the and before the component markup is rendered, then whenever the values that they depend on change.","output":"<script>\nlet a = 1;\nlet b = 2;\n\n// this is a 'reactive statement', and it will re-run\n// when `a`, `b` or `sum` change\n$: console.log(`${a} + ${b} = ${sum}`);\n\n// this is a 'reactive assignment' â€” `sum` will be\n// recalculated when `a` or `b` change. It is\n// not necessary to declare `sum` separately\n$: sum = a + b;\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: In runes mode, event handlers are just like any other attribute or prop.","input":"In runes mode, event handlers are just like any other attribute or prop. In legacy mode, we use the directive:","output":"<!file: App.svelte>\n<script>\nlet count = 0;\n\n/** @param {MouseEvent} event */\nfunction handleClick(event) {\n  count += 1;\n}\n</script>\n\n<button on:click={handleClick}>\n  count: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: It's possible to have multiple event listeners for the same event:","input":"It's possible to have multiple event listeners for the same event:","output":"<!file: App.svelte>\n<script>\nlet count = 0;\n\nfunction increment() {\n  count += 1;\n}\n\n/** @param {MouseEvent} event */\nfunction log(event) {\n  console.log(event);\n}\n</script>\n\n<button on:click={increment} on:click={log}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:self>: The element allows a component to include itself, recursively.","input":"The element allows a component to include itself, recursively. It cannot appear at the top level of your markup; it must be inside an if or each block or passed to a component's slot to prevent an infinite loop.","output":"<script>\nexport let count;\n</script>\n\n{#if count > 0}\n  <p>counting down... {count}</p>\n  <svelte:self count={count - 1} />\n{:else}\n  <p>lift-off!</p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating prefersReducedMotion: A that matches if the user .","input":"A that matches if the user .","output":"<script>\nimport { prefersReducedMotion } from 'svelte/motion';\nimport { fly } from 'svelte/transition';\n\nlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>\n  toggle\n</button>\n\n{#if visible}\n  <p transition:fly={{ y: prefersReducedMotion.current ? 0 : 200 }}>\n    flies in, unless the user prefers reduced motion\n  </p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating page: Changes to are available exclusively with runes.","input":"Changes to are available exclusively with runes. (The legacy reactivity syntax will not reflect any changes)","output":"<!file: +page.svelte>\n<script>\nimport { page } from '$app/state';\n\nconst id = $derived(page.params.id);\n// This will correctly update id for usage on this page\n\n$: badId = page.params.id;\n// Do not use; will never update after initial load\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Snapshots: Ephemeral DOM state â€” like scroll positions on sidebars, the content of elements and so on â€” is discarded when you navigate from one page to another.","input":"Ephemeral DOM state â€” like scroll positions on sidebars, the content of elements and so on â€” is discarded when you navigate from one page to another. For example, if the user fills out a form but navigates away and then back before submitting, or if the user refreshes the page, the values they filled in will be lost. In cases where it's valuable to preserve that input, you can take a of DOM state, which can then be restored if the user navigates back. To do this, export a object with and methods from a or :","output":"<!file: +page.svelte>\n<script>\nlet comment = $state('');\n\n/** @type {import('./$types').Snapshot<string>} */\nexport const snapshot = {\n  capture: () => comment,\n  restore: (value) => comment = value\n};\n</script>\n\n<form method=\"POST\">\n  <label for=\"comment\">Comment</label>\n  <textarea id=\"comment\" bind:value={comment} />\n  <button>Post comment</button>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: Data returned from a layout's function is also available to all its child pages:","input":"Data returned from a layout's function is also available to all its child pages:","output":"<script>\nimport { page } from '$app/state';\n\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\n// we can access `data.posts` because it's returned from\n// the parent layout `load` function\nlet index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));\nlet next = $derived(data.posts[index + 1]);\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#if next}\n  <p>Next post: <a href=\"/blog/{next.slug}\">{next.title}</a></p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating let â†’ $state: Let's migrate the counter to runes mode by wrapping the counter in :","input":"Let's migrate the counter to runes mode by wrapping the counter in :","output":"<script>\nlet count =$state(0);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Event changes: Event handlers have been given a facelift in Svelte 5.","input":"Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):","output":"<script>\nlet count = $state(0);\n</script>\n\n<button on:click={() => count++}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event changes: Since they're just properties, you can use the normal shorthand syntax...","input":"Since they're just properties, you can use the normal shorthand syntax...","output":"<script>\nlet count = $state(0);\n\nfunction onclick() {\n  count++;\n}\n</script>\n\n<button {onclick}>\n  clicks: {count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Component events: In Svelte 4, components could emit events by creating a dispatcher with .","input":"In Svelte 4, components could emit events by creating a dispatcher with . This function is deprecated in Svelte 5. Instead, components should accept - which means you then pass functions as properties to these components:","output":"<!file: App.svelte>\n<script>\nimport Pump from './Pump.svelte';\n\nlet size = $state(15);\nlet burst = $state(false);\n\nfunction reset() {\n  size = 15;\n  burst = false;\n}\n</script>\n\n<Pump\n  on:inflate={(power) => {\n    size += power.detail;\n    if (size > 75) burst = true;\n  }}\n  on:deflate={(power) => {\n    if (size > 0) size -= power.detail;\n  }}\n/>\n\n{#if burst}\n  <button onclick={reset}>new balloon</button>\n  <span class=\"boom\">ðŸ’¥</span>\n{:else}\n  <span class=\"balloon\" style=\"scale: {0.01 * size}\">\n    ðŸŽˆ\n  </span>\n{/if}"}
{"instruction":"Write Svelte 5 code for Component events.","input":"","output":"<!file: Pump.svelte>\n<script>\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\n\nlet { inflate, deflate } = $props();\nlet power = $state(5);\n</script>\n\n<button onclick={() =>dispatch('inflate', power)inflate(power)}>\n  inflate\n</button>\n\n<button onclick={() =>dispatch('deflate', power)deflate(power)}>\n  deflate\n</button>\n\n<button onclick={() => power--}>-</button>\nPump power: {power}\n<button onclick={() => power++}>+</button>"}