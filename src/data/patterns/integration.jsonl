{"instruction":"Write Svelte 5 code for .svelte files.","input":"Components are the building blocks of Svelte applications. They are written into .svelte files, using a superset of HTML. All three sections — script, styles and markup — are optional.","output":"<script module>\n// module-level logic goes here\n// (you will rarely use this)\n</script>\n\n<script>\n// instance-level logic goes here\n</script>\n\n<style>\n/* styles go here */\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating .svelte files: A tag with a attribute runs once when the module first evaluates, rather than for each component instance.","input":"A tag with a attribute runs once when the module first evaluates, rather than for each component instance. Variables declared in this block can be referenced elsewhere in the component, but not vice versa.","output":"<script module>\nlet total = 0;\n</script>\n\n<script>\ntotal += 1;\nconsole.log(`instantiated ${total} times`);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $props: The inputs to a component are referred to as which is short for .","input":"The inputs to a component are referred to as which is short for . You pass props to components just like you pass attributes to elements:","output":"<!file: App.svelte>\n<script>\nimport MyComponent from './MyComponent.svelte';\n</script>\n\n<MyComponent adjective=\"cool\" />"}
{"instruction":"Create a Svelte 5 component demonstrating $props: If the prop is a regular object, the mutation will have no effect ( ):","input":"If the prop is a regular object, the mutation will have no effect ( ):","output":"<!file: App.svelte>\n<script>\nimport Child from './Child.svelte';\n</script>\n\n<Child object={{ count: 0 }} />"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: A lowercase tag, like denotes a regular HTML element.","input":"A lowercase tag, like denotes a regular HTML element. A capitalised tag or a tag that uses dot notation, such as or indicates a .","output":"<script>\nimport Widget from './Widget.svelte';\n</script>\n\n<div>\n  <Widget />\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating use:: An action can be called with an argument:","input":"An action can be called with an argument:","output":"<!file: App.svelte>\n<script>\n/** @type {import('svelte/action').Action} */\nfunction myaction(node,data) {\n  // ...\n}\n</script>\n\n<div use:myaction={data}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Global styles: To apply styles to a single selector globally, use the modifier:","input":"To apply styles to a single selector globally, use the modifier:","output":"<style>\n:global(body) {\n  /* applies to <body> */\n  margin: 0;\n}\n\ndiv :global(strong) {\n  /* applies to all <strong> elements, in any component,\n     that are inside <div> elements belonging to this component */\n  color: goldenrod;\n}\n\np:global(.big.red) {\n  /* applies to all <p> elements belonging to this component with `class=\"big red\"`,\n     even if it is applied programmatically (for example by a library) */\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:element>: Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible.","input":"Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible. You can make it explicit with an attribute:","output":"<svelte:element this={tag} xmlns=\"http://www.w3.org/2000/svg\" />"}
{"instruction":"Create a Svelte 5 component demonstrating Stores: A is an object that allows reactive access to a value via a simple .","input":"A is an object that allows reactive access to a value via a simple . The module contains minimal store implementations which fulfil this contract. Any time you have a reference to a store, you can access its value inside a component by prefixing it with the character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialisation and unsubscribe when appropriate. Assignments to -prefixed variables require that the variable be a writable store, and will result in a call to the store's method. Note that the store must be declared at the top level of the component — not inside an block or a function, for example. Local variables (that do not represent store values) must have a prefix.","output":"<script>\nimport { writable } from 'svelte/store';\n\nconst count = writable(0);\n\nconsole.log($count); // logs 0\n\ncount.set(1);\nconsole.log($count); // logs 1\n\n$count = 2;\nconsole.log($count); // logs 2\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: Context allows components to access values owned by parent components without passing them down as props (potentially through many layers of intermediate components, known as 'prop-drilling').","input":"Context allows components to access values owned by parent components without passing them down as props (potentially through many layers of intermediate components, known as 'prop-drilling'). The parent component sets context with ...","output":"<!file: Parent.svelte>\n<script>\nimport { setContext } from 'svelte';\n\nsetContext('my-context', 'hello from Parent.svelte');\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...and the child retrieves it with :","input":"...and the child retrieves it with :","output":"<!file: Child.svelte>\n<script>\nimport { getContext } from 'svelte';\n\nconst message = getContext('my-context');\n</script>\n\n<h1>{message}, inside Child.svelte</h1>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...then the data may be accessible by the user.","input":"...then the data may be accessible by the user. Context solves this problem because it is not shared between requests.","output":"<!file: App.svelte->\n<script>\nimport { myGlobalState } from 'svelte';\n\nlet { data } = $props();\n\nif (data.user) {\n  myGlobalState.user = data.user;\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating export let: In runes mode, are declared with the rune, allowing parent components to pass in data.","input":"In runes mode, are declared with the rune, allowing parent components to pass in data. In legacy mode, props are marked with the keyword, and can have a default value:","output":"<script>\nexport let foo;\nexport let bar = 'default value';\n\n// Values that are passed in as props\n// are immediately available\nconsole.log({ foo });\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating export let: An exported or declaration is a prop — instead, it becomes part of the component's API:","input":"An exported or declaration is a prop — instead, it becomes part of the component's API:","output":"<!file: Greeter.svelte>\n<script>\nexport function greet(name) {\n  alert(`hello ${name}!`);\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating export let: The keyword can appear separately from the declaration.","input":"The keyword can appear separately from the declaration. This is useful for renaming props, for example in the case of a reserved word:","output":"<!file: App.svelte>\n<script>\n/** @type {string} */\nlet className;\n\n// creates a `class` property, even\n// though it is a reserved word\nexport { className as class };\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $$props and $$restProps: In runes mode, getting an object containing all the props that were passed in is easy, using the rune.","input":"In runes mode, getting an object containing all the props that were passed in is easy, using the rune. In legacy mode, we use and :","output":"<script>\nexport let variant;\n</script>\n\n<button {...$$restProps} class=\"variant-{variant} {$$props.class ?? ''}\">\n  click me\n</button>\n\n<style>\n.variant-danger {\n  background: red;\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Spring: Create a spring whose value is bound to the return value of .","input":"Create a spring whose value is bound to the return value of . This must be called inside an effect root (for example, during component initialisation).","output":"<script>\nimport { Spring } from 'svelte/motion';\n\nlet { number } = $props();\nconst spring = Spring.of(() => number);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Tween: Create a tween whose value is bound to the return value of .","input":"Create a tween whose value is bound to the return value of . This must be called inside an effect root (for example, during component initialisation).","output":"<script>\nimport { Tween } from 'svelte/motion';\n\nlet { number } = $props();\nconst tween = Tween.of(() => number);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating MediaQuery: Creates a media query and provides a property that reflects whether or not it matches.","input":"Creates a media query and provides a property that reflects whether or not it matches. Use it carefully — during server-side rendering, there is no way to know what the correct value should be, potentially causing content to change upon hydration. If you can use the media query in CSS to achieve the same effect, do that.","output":"<script>\nimport { MediaQuery } from 'svelte/reactivity';\n\nconst large = new MediaQuery('min-width: 800px');\n</script>\n\n<h1>{large.current ? 'large screen' : 'small screen'}</h1>"}
{"instruction":"Write Svelte 5 code for $lib.","input":"SvelteKit automatically makes files under available using the import alias. You can change which directory this alias points to in your .","output":"<!file: src/lib/Component.svelte>\n"}
{"instruction":"Write Svelte 5 code for $lib.","input":"","output":"<!file: src/routes/+page.svelte>\n<script>\nimport Component from '$lib/Component.svelte';\n</script>\n\n<Component />"}
{"instruction":"Create a Svelte 5 component demonstrating page: A read-only reactive object with information about the current page, serving several use cases:","input":"A read-only reactive object with information about the current page, serving several use cases:","output":"<!file: +layout.svelte>\n<script>\nimport { page } from '$app/state';\n</script>\n\n<p>Currently at {page.url.pathname}</p>\n\n{#if page.error}\n  <span class=\"red\">Problem detected</span>\n{:else}\n  <span class=\"small\">All systems operational</span>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating Shallow routing: As you navigate around a SvelteKit app, you create .","input":"As you navigate around a SvelteKit app, you create . Clicking the back and forward buttons traverses through this list of entries, re-running any functions and replacing page components as necessary. Sometimes, it's useful to create history entries navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page. SvelteKit makes this possible with the and functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal:","output":"<!file: +page.svelte>\n<script>\nimport { pushState } from '$app/navigation';\nimport { page } from '$app/state';\nimport Modal from './Modal.svelte';\n\nfunction showModal() {\n  pushState('', { showModal: true });\n}\n</script>\n\n{#if page.state.showModal}\n  <Modal close={() => history.back()} />\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: You can also manually import an image asset and pass it to an .","input":"You can also manually import an image asset and pass it to an . This is useful when you have a collection of static images and would like to dynamically choose one or . In this case you will need to update both the statement and element as shown below to indicate you'd like process them.","output":"<script>\nimport MyImage from './path/to/your/image.jpg?enhanced';\n</script>\n\n<enhanced:img src={MyImage} alt=\"some alt text\" />"}
{"instruction":"Create a Svelte 5 component demonstrating <enhanced:img>: You can also use .","input":"You can also use . Note that you will have to specify via a :","output":"<script>\n  const imageModules = import.meta.glob(\n    '/path/to/assets/*.{avif,gif,heif,jpeg,jpg,png,tiff,webp,svg}',\n    {\n      eager: true,\n      query: { enhanced: true }\n    }\n  )\n</script>\n\n{#each Object.entries(imageModules) as [_path, module]}\n  <enhanced:img src={module.default} alt=\"some alt text\" />\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating Using state and stores with context: You might wonder how we're able to use and other (or ) if we can't use global state.","input":"You might wonder how we're able to use and other (or ) if we can't use global state. The answer is that app state and app stores on the server use Svelte's — the state (or store) is attached to the component tree with and when you subscribe you retrieve it with . We can do the same thing with our own state:","output":"<!file: src/routes/+layout.svelte>\n<script>\nimport { setContext } from 'svelte';\n\n/** @type {import('./$types').LayoutProps} */\nlet { data } = $props();\n\n// Pass a function referencing our state\n// to the context for child components to access\nsetContext('user', () => data.user);\n</script>"}
{"instruction":"Write Svelte 5 code for Using state and stores with context.","input":"","output":"<!file: src/routes/user/+page.svelte>\n<script>\nimport { getContext } from 'svelte';\n\n// Retrieve user store from context\nconst user = getContext('user');\n</script>\n\n<p>Welcome {user().name}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating Component and page state is preserved: When you navigate around your application, SvelteKit reuses existing layout and page components.","input":"When you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\n// THIS CODE IS BUGGY!\nconst wordCount = data.content.split(' ').length;\nconst estimatedReadingTime = wordCount / 250;\n</script>\n\n<header>\n  <h1>{data.title}</h1>\n  <p>Reading time: {Math.round(estimatedReadingTime)} minutes</p>\n</header>\n\n<div>{@html data.content}</div>"}
{"instruction":"Create a Svelte 5 component demonstrating +page.svelte: Pages can receive data from functions via the prop.","input":"Pages can receive data from functions via the prop.","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n</script>\n\n<h1>{data.title}</h1>\n<div>{@html data.content}</div>"}
{"instruction":"Create a Svelte 5 component demonstrating +error: If an error occurs during SvelteKit will render a default error page.","input":"If an error occurs during SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an file:","output":"<!file: src/routes/blog/[slug]/+error.svelte>\n<script>\nimport { page } from '$app/state';\n</script>\n\n<h1>{page.status}: {page.error.message}</h1>"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: We can create a layout that only applies to pages below (while inheriting the root layout with the top-level nav):","input":"We can create a layout that only applies to pages below (while inheriting the root layout with the top-level nav):","output":"<!file: src/routes/settings/+layout.svelte>\n<script>\n/** @type {import('./$types').LayoutProps} */\nlet { data, children } = $props();\n</script>\n\n<h1>Settings</h1>\n\n<div class=\"submenu\">\n  {#each data.sections as section}\n    <a href=\"/settings/{section.slug}\">{section.title}</a>\n  {/each}\n</div>\n\n{@render children()}"}
{"instruction":"Create a Svelte 5 component demonstrating +layout.svelte: The component, and each component above it, has access to its own data plus all the data from its parents.","input":"The component, and each component above it, has access to its own data plus all the data from its parents. In some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a property returned from a function in or . This can be done with :","output":"<!file: src/routes/+layout.svelte>\n<script>\nimport { page } from '$app/state';\n</script>\n\n<svelte:head>\n  <title>{page.data.title}</title>\n</svelte:head>"}
{"instruction":"Create a Svelte 5 component demonstrating $types: For example, annotating with (or for a file) tells TypeScript that the type of is whatever was returned from :","input":"For example, annotating with (or for a file) tells TypeScript that the type of is whatever was returned from :","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Anatomy of an action: Each action receives a object, allowing you to read the data with .","input":"Each action receives a object, allowing you to read the data with . After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the property on the corresponding page and through app-wide until the next update.","output":"<!file: src/routes/login/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data, form } = $props();\n</script>\n\n{#if form?.success}\n  <p>Successfully logged in! Welcome back, {data.user.name}</p>\n{/if}\n\n"}
{"instruction":"Create a Svelte 5 component demonstrating Validation errors: If the request couldn't be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again.","input":"If the request couldn't be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again. The function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through and the data through :","output":"<form method=\"POST\" action=\"?/login\">\n  {#if form?.missing}<p class=\"error\">The email field is required</p>{/if}\n  {#if form?.incorrect}<p class=\"error\">Invalid credentials!</p>{/if}\n\n  <label>\n    Email\n    <input name=\"email\" type=\"email\"value={form?.email ?? ''}>\n  </label>\n  <label>\n    Password\n    <input name=\"password\" type=\"password\">\n  </label>\n  <button>Log in</button>\n  <button formaction=\"?/register\">Register</button>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating use:enhance: The easiest way to progressively enhance a form is to add the action:","input":"The easiest way to progressively enhance a form is to add the action:","output":"<script>\nimport { enhance } from '$app/forms';\n\n/** @type {import('./$types').PageProps} */\nlet { form } = $props();\n</script>\n\n<form method=\"POST\"use:enhance>\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Customising use:enhance: If you return a callback, you may need to reproduce part of the default behaviour, but without invalidating all data on a successful response.","input":"If you return a callback, you may need to reproduce part of the default behaviour, but without invalidating all data on a successful response. You can do so with :","output":"<script>\nimport { enhance,applyAction} from '$app/forms';\n\n/** @type {import('./$types').PageProps} */\nlet { form } = $props();\n</script>\n\n<form\n  method=\"POST\"\n  use:enhance={({ formElement, formData, action, cancel }) => {\n    return async ({ result }) => {\n      // `result` is an `ActionResult` object\n      if (result.type === 'redirect') {\n        goto(result.location);\n      } else {\n        await applyAction(result);\n      }\n    };\n  }}\n>\n  \n</form>"}
{"instruction":"Write Svelte 5 code for Streaming with promises.","input":"This is useful for creating skeleton loading states, for example:","output":"<!file: src/routes/blog/[slug]/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}"}
{"instruction":"Write Svelte 5 code for $types.","input":"The return types of the load functions are then available through the module as and respectively, while the union of the return values of all is available as . Starting with version 2.16.0, two additional helper types are provided: defines as well as when there are actions defined, while defines as well as .","output":"<!file: src/routes/+page.svelte>\n<script>\n/** @type {import('./$types').PageProps} */\nlet { data, form } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating When to use layout groups: Not all use cases are suited for layout grouping, nor should you feel compelled to use them.","input":"Not all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex nesting, or that you don't want to introduce a for a single outlier. It's perfectly fine to use other means such as composition (reusable functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:","output":"<!file: src/routes/nested/route/+layout@.svelte>\n<script>\nimport ReusableLayout from '$lib/ReusableLayout.svelte';\n\nlet { data, children } = $props();\n</script>\n\n<ReusableLayout {data}>\n  {@render children()}\n</ReusableLayout>"}
{"instruction":"Create a Svelte 5 component demonstrating bundleStrategy?: 'split' | 'single' | 'inline';: If you want to inline your assets, you'll need to set Vite's option to an appropriate size then import your assets through Vite.","input":"If you want to inline your assets, you'll need to set Vite's option to an appropriate size then import your assets through Vite.","output":"<script>\n// import the asset through Vite\nimport favicon from './favicon.png';\n</script>\n\n<svelte:head>\n  <link rel=\"icon\" href={favicon} />\n</svelte:head>"}
{"instruction":"Write Svelte 5 code for version.","input":"If you set to a non-zero value, SvelteKit will poll for new versions in the background and set the value of when it detects one.","output":"<script>\nimport { beforeNavigate } from '$app/navigation';\nimport { updated } from '$app/state';\n\nbeforeNavigate(({ willUnload, to }) => {\n  if (updated.current && !willUnload && to?.url) {\n    location.href = to.url.href;\n  }\n});\n</script>"}
{"instruction":"Write Svelte 5 code for How do I use a client-side library accessing `document` or `window`?.","input":"If the library you'd like to use is side-effect free you can also statically import it and it will be tree-shaken out in the server-side build where will be automatically replaced with a no-op:","output":""}
{"instruction":"Create a Svelte 5 component demonstrating How do I use a client-side library accessing `document` or `window`?: Finally, you may also consider using an block:","input":"Finally, you may also consider using an block:","output":"<!file: index.svelte>\n<script>\nimport { browser } from '$app/environment';\n\nconst ComponentConstructor = browser\n  ? import('some-browser-only-library').then((module) => module.Component)\n  : new Promise(() => {});\n</script>\n\n{#await ComponentConstructor}\n  <p>Loading...</p>\n{:then component}\n  <svelte:component this={component} />\n{:catch error}\n  <p>Something went wrong: {error.message}</p>\n{/await}"}
{"instruction":"Create a Svelte 5 component demonstrating SvelteComponentTyped is deprecated: If you have used as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing to .","input":"If you have used as the component instance type previously, you may see a somewhat opaque type error now, which is solved by changing to .","output":"<script>\nimport ComponentA from './ComponentA.svelte';\nimport ComponentB from './ComponentB.svelte';\nimport { SvelteComponent } from 'svelte';\n\nlet component: typeof SvelteComponent<any>;\n\nfunction choseRandomly() {\n  component = Math.random() > 0.5 ? ComponentA : ComponentB;\n}\n</script>\n\n<button on:click={choseRandomly}>random</button>\n<svelte:element this={component} />"}
{"instruction":"Create a Svelte 5 component demonstrating export let → $props: In Svelte 4, properties of a component were declared using .","input":"In Svelte 4, properties of a component were declared using . Each property was one declaration. In Svelte 5, all properties are declared through the rune, through destructuring:","output":"<script>\nexport let optional = 'unset';\nexport let required;\n\nlet { optional = 'unset', required } = $props();\n</script>"}