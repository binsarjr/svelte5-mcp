{"instruction":"Create a Svelte 5 component demonstrating Overview: Svelte is a framework for building user interfaces on the web.","input":"Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript.","output":"<!file: App.svelte>\n<script>\nfunction greet() {\n  alert('Welcome to Svelte!');\n}\n</script>\n\n<button onclick={greet}>click me</button>\n\n<style>\nbutton {\n  font-size: 2em;\n}\n</style>"}
{"instruction":"Write Svelte 5 code for $props.","input":"","output":"<!file: Child.svelte>\n<script>\nlet { count } = $props();\n</script>\n\n<button onclick={() => (count += 1)}>\n  clicks (child): {count}\n</button>"}
{"instruction":"Write Svelte 5 code for $props.","input":"","output":"<!file: Child.svelte>\n<script>\nlet { object } = $props();\n</script>\n\n<button onclick={() => {\n  // has no effect\n  object.count += 1\n}}>\n  clicks: {object.count}\n</button>"}
{"instruction":"Write Svelte 5 code for $props.","input":"","output":"<!file: Child.svelte>\n<script>\nlet { object } = $props();\n</script>\n\n<button onclick={() => {\n  // will cause the count below to update,\n  // but with a warning. Don't mutate\n  // objects you don't own!\n  object.count += 1\n}}>\n  clicks: {object.count}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $bindable: Ordinarily, props go one way, from parent to child.","input":"Ordinarily, props go one way, from parent to child. This makes it easy to understand how data flows around your app. In Svelte, component props can be which means that data can also flow from child to parent. This isn't something you should do often, but it can simplify your code if used sparingly and carefully. It also means that a state proxy can be in the child. To mark a prop as bindable, we use the rune:","output":"<script>\nlet { value = $bindable(), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n\n<style>\ninput {\n  font-family: 'Comic Sans MS';\n  color: deeppink;\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating $host: When compiling a component as a the rune provides access to the host element, allowing you to (for example) dispatch custom events ( ):","input":"When compiling a component as a the rune provides access to the host element, allowing you to (for example) dispatch custom events ( ):","output":"<svelte:options customElement=\"my-stepper\" />\n\n<script>\nfunction dispatch(type) {\n  $host().dispatchEvent(new CustomEvent(type));\n}\n</script>\n\n<button onclick={() => dispatch('decrement')}>decrement</button>\n<button onclick={() => dispatch('increment')}>increment</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: Listening to DOM events is possible by adding attributes to the element that start with .","input":"Listening to DOM events is possible by adding attributes to the element that start with . For example, to listen to the event, add the attribute to a button:","output":"<button onclick={() => console.log('clicked')}>click me</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: The expression will be stringified and escaped to prevent code injections.","input":"The expression will be stringified and escaped to prevent code injections. If you want to render HTML, use the tag instead.","output":"{@html potentiallyUnsafeHtmlString}"}
{"instruction":"Create a Svelte 5 component demonstrating Basic markup: Comments beginning with disable warnings for the next block of markup.","input":"Comments beginning with disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you're disabling them for a good reason.","output":"\n<input bind:value={name} autofocus />"}
{"instruction":"Create a Svelte 5 component demonstrating {#each ...}: In case you just want to render something times, you can omit the part ( ):","input":"In case you just want to render something times, you can omit the part ( ):","output":"<div class=\"chess-board\">\n  {#each { length: 8 }, rank}\n    {#each { length: 8 }, file}\n      <div class:black={(rank + file) % 2 === 1}></div>\n    {/each}\n  {/each}\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating {#key ...}: It's also useful if you want a transition to play whenever a value changes:","input":"It's also useful if you want a transition to play whenever a value changes:","output":"{#key value}\n  <div transition:fade>{value}</div>\n{/key}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets, and are a way to create reusable chunks of markup inside your components.","input":"Snippets, and are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like ...","output":"{#snippet figure(image)}\n  <figure>\n    <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n    <figcaption>{image.caption}</figcaption>\n  </figure>\n{/snippet}\n\n{#each images as image}\n  {#if image.href}\n    <a href={image.href}>\n      {@render figure(image)}\n    </a>\n  {:else}\n    {@render figure(image)}\n  {/if}\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets can be declared anywhere inside your component.","input":"Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the tag or in blocks ( )...","output":"<script>\nlet { message = `it's great to see you!` } = $props();\n</script>\n\n{#snippet hello(name)}\n  <p>hello {name}! {message}!</p>\n{/snippet}\n\n{@render hello('alice')}\n{@render hello('bob')}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: ...and they are 'visible' to everything in the same lexical scope (i.e.","input":"...and they are 'visible' to everything in the same lexical scope (i.e. siblings, and children of those siblings):","output":"<div>\n  {#snippet x()}\n    {#snippet y()}...{/snippet}\n    {@render y()}\n  {/snippet}\n  {@render y()}\n</div>\n\n{@render x()}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets can reference themselves and each other ( ):","input":"Snippets can reference themselves and each other ( ):","output":"{#snippet blastoff()}\n  <span>ðŸš€</span>\n{/snippet}\n\n{#snippet countdown(n)}\n  {#if n > 0}\n    <span>{n}...</span>\n    {@render countdown(n - 1)}\n  {:else}\n    {@render blastoff()}\n  {/if}\n{/snippet}\n\n{@render countdown(10)}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Within the template, snippets are values just like any other.","input":"Within the template, snippets are values just like any other. As such, they can be passed to components as props ( ):","output":"<script>\nimport Table from './Table.svelte';\n\nconst fruits = [\n  { name: 'apples', qty: 5, price: 2 },\n  { name: 'bananas', qty: 10, price: 1 },\n  { name: 'cherries', qty: 20, price: 0.5 }\n];\n</script>\n\n{#snippet header()}\n  <th>fruit</th>\n  <th>qty</th>\n  <th>price</th>\n  <th>total</th>\n{/snippet}\n\n{#snippet row(d)}\n  <td>{d.name}</td>\n  <td>{d.qty}</td>\n  <td>{d.price}</td>\n  <td>{d.qty * d.price}</td>\n{/snippet}\n\n<Table data={fruits} {header} {row} />"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: As an authoring convenience, snippets declared directly a component implicitly become props the component ( ):","input":"As an authoring convenience, snippets declared directly a component implicitly become props the component ( ):","output":"<Table data={fruits}>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n</Table>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Any content inside the component tags that is a snippet declaration implicitly becomes part of the snippet ( ):","input":"Any content inside the component tags that is a snippet declaration implicitly becomes part of the snippet ( ):","output":"<!file: App.svelte>\n<Button>click me</Button>"}
{"instruction":"Write Svelte 5 code for {#snippet ...}.","input":"","output":"<!file: Button.svelte>\n<script>\nlet { children } = $props();\n</script>\n\n<button>{@render children()}</button>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: You can declare snippet props as being optional.","input":"You can declare snippet props as being optional. You can either use optional chaining to not render anything if the snippet isn't set...","output":"<script>\nlet { children } = $props();\n</script>\n\n{@render children?.()}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: ...or use an block to render fallback content:","input":"...or use an block to render fallback content:","output":"<script>\nlet { children } = $props();\n</script>\n\n{#if children}\n  {@render children()}\n{:else}\n  fallback content\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets implement the interface imported from :","input":"Snippets implement the interface imported from :","output":"<script lang=\"ts\">\nimport type { Snippet } from 'svelte';\n\ninterface Props {\n  data: any[];\n  children: Snippet;\n  row: Snippet<[any]>;\n}\n\nlet { data, children, row }: Props = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: We can tighten things up further by declaring a generic, so that and refer to the same type:","input":"We can tighten things up further by declaring a generic, so that and refer to the same type:","output":"<script lang=\"ts\" generics=\"T\">\nimport type { Snippet } from 'svelte';\n\nlet {\n  data,\n  children,\n  row\n}: {\n  data: T[];\n  children: Snippet;\n  row: Snippet<[T]>;\n} = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating {#snippet ...}: Snippets declared at the top level of a file can be exported from a for use in other components, provided they don't reference any declarations in a non-module (whether directly or indirectly, via other snippets) ( ):","input":"Snippets declared at the top level of a file can be exported from a for use in other components, provided they don't reference any declarations in a non-module (whether directly or indirectly, via other snippets) ( ):","output":"<script module>\nexport { add };\n</script>\n\n{#snippet add(a, b)}\n  {a} + {b} = {a + b}\n{/snippet}"}
{"instruction":"Create a Svelte 5 component demonstrating {@render ...}: To render a use a tag.","input":"To render a use a tag.","output":"{#snippet sum(a, b)}\n  <p>{a} + {b} = {a + b}</p>\n{/snippet}\n\n{@render sum(1, 2)}\n{@render sum(3, 4)}\n{@render sum(5, 6)}"}
{"instruction":"Create a Svelte 5 component demonstrating {@render ...}: The expression can be an identifier like or an arbitrary JavaScript expression:","input":"The expression can be an identifier like or an arbitrary JavaScript expression:","output":"{@render (cool ? coolSnippet : lameSnippet)()}"}
{"instruction":"Create a Svelte 5 component demonstrating {@render ...}: If the snippet is potentially undefined â€” for example, because it's an incoming prop â€” then you can use optional chaining to only render it when it defined:","input":"If the snippet is potentially undefined â€” for example, because it's an incoming prop â€” then you can use optional chaining to only render it when it defined:","output":"{@render children?.()}"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Data ordinarily flows down, from parent to child.","input":"Data ordinarily flows down, from parent to child. The directive allows data to flow the other way, from child to parent. The general syntax is where is an (i.e. a variable or an object property). When the expression is an identifier with the same name as the property, we can omit the expression â€” in other words these are equivalent:","output":"<input bind:value={value} />\n<input bind:value />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: You can also use where and are functions, allowing you to perform validation and transformation:","input":"You can also use where and are functions, allowing you to perform validation and transformation:","output":"<input bind:value={\n  () => value,\n  (v) => value = v.toLowerCase()\n} />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: In the case of readonly bindings like the value should be :","input":"In the case of readonly bindings like the value should be :","output":"<div\n  bind:clientWidth={null, redraw}\n  bind:clientHeight={null, redraw}\n>\n  ...\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Checkbox and radio inputs can be bound with :","input":"Checkbox and radio inputs can be bound with :","output":"<label>\n  <input type=\"checkbox\" bind:checked={accepted} />\n  Accept terms and conditions\n</label>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: A value binding corresponds to the property on the selected which can be any value (not just strings, as is normally the case in the DOM).","input":"A value binding corresponds to the property on the selected which can be any value (not just strings, as is normally the case in the DOM).","output":"<select bind:value={selected}>\n  <option value={a}>a</option>\n  <option value={b}>b</option>\n  <option value={c}>c</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: A element behaves similarly to a checkbox group.","input":"A element behaves similarly to a checkbox group. The bound variable is an array with an entry corresponding to the property of each selected .","output":"<select multiple bind:value={fillings}>\n  <option value=\"Rice\">Rice</option>\n  <option value=\"Beans\">Beans</option>\n  <option value=\"Cheese\">Cheese</option>\n  <option value=\"Guac (extra)\">Guac (extra)</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: When the value of an matches its text content, the attribute can be omitted.","input":"When the value of an matches its text content, the attribute can be omitted.","output":"<select multiple bind:value={fillings}>\n  <option>Rice</option>\n  <option>Beans</option>\n  <option>Cheese</option>\n  <option>Guac (extra)</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: You can give the a default value by adding a attribute to the (or options, in the case of ) that should be initially selected.","input":"You can give the a default value by adding a attribute to the (or options, in the case of ) that should be initially selected. If the is part of a form, it will revert to that selection when the form is reset. Note that for the initial render the value of the binding takes precedence if it's not .","output":"<select bind:value={selected}>\n  <option value={a}>a</option>\n  <option value={b} selected>b</option>\n  <option value={c}>c</option>\n</select>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements have their own set of bindings â€” five two-way ones...","input":"elements have their own set of bindings â€” five two-way ones...","output":"<audio\n  src={clip}\n  bind:duration\n  bind:currentTime\n  bind:paused\n></audio>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements have all the same bindings as elements, plus readonly and bindings.","input":"elements have all the same bindings as elements, plus readonly and bindings.","output":""}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements have two readonly bindings:","input":"elements have two readonly bindings:","output":""}
{"instruction":"Create a Svelte 5 component demonstrating bind:: elements support binding to the property.","input":"elements support binding to the property.","output":"<details bind:open={isOpen}>\n  <summary>How do you comfort a JavaScript bug?</summary>\n  <p>You console it.</p>\n</details>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Elements with the attribute support the following bindings:","input":"Elements with the attribute support the following bindings:","output":"<div contenteditable=\"true\" bind:innerHTML={html}></div>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: All visible elements have the following readonly bindings, measured with a :","input":"All visible elements have the following readonly bindings, measured with a :","output":"<div bind:offsetWidth={width} bind:offsetHeight={height}>\n  <Chart {width} {height} />\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Components also support allowing you to interact with component instances programmatically.","input":"Components also support allowing you to interact with component instances programmatically.","output":"<!file: App.svelte>\n<ShoppingCart bind:this={cart} />\n\n<button onclick={() => cart.empty()}>\n  Empty shopping cart\n</button>"}
{"instruction":"Write Svelte 5 code for bind:.","input":"","output":"<!file: ShoppingCart.svelte>\n<script>\n// All instance exports are available on the instance object\nexport function empty() {\n  // ...\n}\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: You can bind to component props using the same syntax as for elements.","input":"You can bind to component props using the same syntax as for elements.","output":"<Keypad bind:value={pin} />"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: While Svelte props are reactive without binding, that reactivity only flows downward into the component by default.","input":"While Svelte props are reactive without binding, that reactivity only flows downward into the component by default. Using allows changes to the property from within the component to flow back up out of the component. To mark a property as bindable, use the rune:","output":"<script>\nlet { readonlyProperty, bindableProperty = $bindable() } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: Bindable properties can have a fallback value:","input":"Bindable properties can have a fallback value:","output":"<script>\nlet { bindableProperty = $bindable('fallback value') } = $props();\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: Transitions are local by default.","input":"Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, when parent blocks are created or destroyed.","output":"{#if x}\n  {#if y}\n    <p transition:fade>fades in and out only when y changes</p>\n    <p transition:fade|global>fades in and out when x or y change</p>\n  {/if}\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: Transitions can have parameters.","input":"Transitions can have parameters. (The double aren't a special syntax; this is an object literal inside an expression tag.)","output":"{#if visible}\n  <div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: Transitions can use custom functions.","input":"Transitions can use custom functions. If the returned object has a function, Svelte will generate keyframes for a . The argument passed to is a value between and after the function has been applied. transitions run from to transitions run from to â€” in other words, is the element's natural state, as though no transition had been applied. The argument is equal to . The function is called repeatedly the transition begins, with different and arguments.","output":"<!file: App.svelte>\n<script>\nimport { elasticOut } from 'svelte/easing';\n\n/** @type {boolean} */\nexport let visible;\n\n/**\n * @param {HTMLElement} node\n * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n */\nfunction whoosh(node, params) {\n  const existingTransform = getComputedStyle(node).transform.replace('none', '');\n\n  return {\n    delay: params.delay || 0,\n    duration: params.duration || 400,\n    easing: params.easing || elasticOut,\n    css: (t, u) => `transform: ${existingTransform} scale(${t})`\n  };\n}\n</script>\n\n{#if visible}\n  <div in:whoosh>whooshes in</div>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: A custom transition function can also return a function, which is called the transition with the same and arguments.","input":"A custom transition function can also return a function, which is called the transition with the same and arguments.","output":"<!file: App.svelte>\n<script>\nexport let visible = false;\n\n/**\n * @param {HTMLElement} node\n * @param {{ speed?: number }} params\n */\nfunction typewriter(node, { speed = 1 }) {\n  const valid =\n    node.childNodes.length === 1 &&\n    node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n  if (!valid) {\n    throw new Error(\n      `This transition only works on elements with a single text node child`\n    );\n  }\n\n  const text = node.textContent;\n  const duration = text.length / (speed * 0.01);\n\n  return {\n    duration,\n    tick: (t) => {\n      const i = ~~(text.length * t);\n      node.textContent = text.slice(0, i);\n    }\n  };\n}\n</script>\n\n{#if visible}\n  <p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating transition:: An element with transitions will dispatch the following events in addition to any standard DOM events:","input":"An element with transitions will dispatch the following events in addition to any standard DOM events:","output":"{#if visible}\n  <p\n    transition:fly={{ y: 200, duration: 2000 }}\n    onintrostart={() => (status = 'intro started')}\n    onoutrostart={() => (status = 'outro started')}\n    onintroend={() => (status = 'intro ended')}\n    onoutroend={() => (status = 'outro ended')}\n  >\n    Flies in and out\n  </p>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: An animation is triggered when the contents of a are re-ordered.","input":"An animation is triggered when the contents of a are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an child of a keyed each block. Animations can be used with Svelte's or .","output":"{#each list as item, index (item)}\n  <li animate:flip>{item}</li>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: As with actions and transitions, animations can have parameters.","input":"As with actions and transitions, animations can have parameters. (The double aren't a special syntax; this is an object literal inside an expression tag.)","output":"{#each list as item, index (item)}\n  <li animate:flip={{ delay: 500 }}>{item}</li>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: Animations can use custom functions that provide the an object and any as arguments.","input":"Animations can use custom functions that provide the an object and any as arguments. The parameter is an object containing and properties each containing a describing the geometry of the element in its and positions. The property is the DOMRect of the element in its starting position, and the property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated. If the returned object has a method, Svelte will create a that plays on the element. The argument passed to is a value that goes from and after the function has been applied. The argument is equal to . The function is called repeatedly the animation begins, with different and arguments.","output":"<!file: App.svelte>\n<script>\nimport { cubicOut } from 'svelte/easing';\n\n/**\n * @param {HTMLElement} node\n * @param {{ from: DOMRect; to: DOMRect }} states\n * @param {any} params\n */\nfunction whizz(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    delay: 0,\n    duration: Math.sqrt(d) * 120,\n    easing: cubicOut,\n    css: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n  };\n}\n</script>\n\n{#each list as item, index (item)}\n  <div animate:whizz>{item}</div>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating animate:: A custom animation function can also return a function, which is called the animation with the same and arguments.","input":"A custom animation function can also return a function, which is called the animation with the same and arguments.","output":"<!file: App.svelte>\n<script>\nimport { cubicOut } from 'svelte/easing';\n\n/**\n * @param {HTMLElement} node\n * @param {{ from: DOMRect; to: DOMRect }} states\n * @param {any} params\n */\nfunction whizz(node, { from, to }, params) {\n  const dx = from.left - to.left;\n  const dy = from.top - to.top;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  return {\n    delay: 0,\n    duration: Math.sqrt(d) * 120,\n    easing: cubicOut,\n    tick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n  };\n}\n</script>\n\n{#each list as item, index (item)}\n  <div animate:whizz>{item}</div>\n{/each}"}
{"instruction":"Create a Svelte 5 component demonstrating style:: The directive provides a shorthand for setting multiple styles on an element.","input":"The directive provides a shorthand for setting multiple styles on an element.","output":"<div style:color=\"red\">...</div>\n\n<div style=\"color: red;\">...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: The value can contain arbitrary expressions:","input":"The value can contain arbitrary expressions:","output":"<div style:color={myColor}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: The shorthand form is allowed:","input":"The shorthand form is allowed:","output":"<div style:color>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: Multiple styles can be set on a single element:","input":"Multiple styles can be set on a single element:","output":"<div style:color style:width=\"12rem\" style:background-color={darkMode ? 'black' : 'white'}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: To mark a style as important, use the modifier:","input":"To mark a style as important, use the modifier:","output":"<div style:color|important=\"red\">...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating style:: When directives are combined with attributes, the directives will take precedence:","input":"When directives are combined with attributes, the directives will take precedence:","output":"<div style=\"color: blue;\" style:color=\"red\">This will be red</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Primitive values are treated like any other attribute:","input":"Primitive values are treated like any other attribute:","output":"<div class={large ? 'large' : 'small'}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: If the value is an object, the truthy keys are added:","input":"If the value is an object, the truthy keys are added:","output":"<script>\nlet { cool } = $props();\n</script>\n\n<div class={{ cool, lame: !cool }}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: If the value is an array, the truthy values are combined:","input":"If the value is an array, the truthy values are combined:","output":"<div class={[faded && 'saturate-0 opacity-50', large && 'scale-200']}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Arrays can contain arrays and objects, and clsx will flatten them.","input":"Arrays can contain arrays and objects, and clsx will flatten them. This is useful for combining local classes with props, for example:","output":"<!file: Button.svelte>\n<script>\nlet props = $props();\n</script>\n\n<button {...props} class={['cool-button', props.class]}>\n  {@render props.children?.()}\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Svelte also exposes the type, which is the type of value that the attribute on elements accept.","input":"Svelte also exposes the type, which is the type of value that the attribute on elements accept. This is useful if you want to use a type-safe class name in component props:","output":"<script lang=\"ts\">\nimport type { ClassValue } from 'svelte/elements';\n\nconst props: { class: ClassValue } = $props();\n</script>\n\n<div class={['original', props.class]}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: Prior to Svelte 5.16, the directive was the most convenient way to set classes on elements conditionally.","input":"Prior to Svelte 5.16, the directive was the most convenient way to set classes on elements conditionally.","output":"<div class={{ cool, lame: !cool }}>...</div>\n\n<div class:cool={cool} class:lame={!cool}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating class: As with other directives, we can use a shorthand when the name of the class coincides with the value:","input":"As with other directives, we can use a shorthand when the name of the class coincides with the value:","output":"<div class:cool class:lame={!cool}>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Scoped styles: If a component defines the name is scoped to the component using the same hashing approach.","input":"If a component defines the name is scoped to the component using the same hashing approach. Any rules in the component will be similarly adjusted:","output":"<style>\n.bouncy {\n  animation: bounce 10s;\n}\n\n/* these keyframes are only accessible inside this component */\n@keyframes bounce {\n  /* ... */\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Global styles: If you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with .","input":"If you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with . The part will be removed when compiled, and the keyframe will then be referenced using just elsewhere in your code.","output":"<style>\n@keyframes -global-my-animation-name {\n  /* code goes here */\n}\n</style>"}
{"instruction":"Create a Svelte 5 component demonstrating Custom properties: You can pass CSS custom properties â€” both static and dynamic â€” to components:","input":"You can pass CSS custom properties â€” both static and dynamic â€” to components:","output":"<Slider\n  bind:value\n  min={0}\n  max={100}\n  --track-color=\"black\"\n  --thumb-color=\"rgb({r} {g} {b})\"\n/>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:boundary>: Boundaries allow you to guard against errors in part of your app from breaking the app as a whole, and to recover from those errors.","input":"Boundaries allow you to guard against errors in part of your app from breaking the app as a whole, and to recover from those errors. If an error occurs while rendering or updating the children of a or running any functions contained therein, the contents will be removed. Errors occurring outside the rendering process (for example, in event handlers or after a or async work) are caught by error boundaries.","output":"<svelte:boundary onerror={handler}>...</svelte:boundary>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:boundary>: If a snippet is provided, it will be rendered with the error that was thrown, and a function that recreates the contents ( ):","input":"If a snippet is provided, it will be rendered with the error that was thrown, and a function that recreates the contents ( ):","output":"<svelte:boundary>\n  <FlakyComponent />\n\n  {#snippet failed(error, reset)}\n    <button onclick={reset}>oops! try again</button>\n  {/snippet}\n</svelte:boundary>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:window>: The element allows you to add event listeners to the object without worrying about removing them when the component is destroyed, or checking for the existence of when server-side rendering.","input":"The element allows you to add event listeners to the object without worrying about removing them when the component is destroyed, or checking for the existence of when server-side rendering. This element may only appear at the top level of your component â€” it cannot be inside a block or element.","output":"<script>\nfunction handleKeydown(event) {\n  alert(`pressed the ${event.key} key`);\n}\n</script>\n\n<svelte:window onkeydown={handleKeydown} />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:window>: You can also bind to the following properties:","input":"You can also bind to the following properties:","output":"<svelte:window bind:scrollY={y} />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:document>: Similarly to this element allows you to add listeners to events on such as which don't fire on .","input":"Similarly to this element allows you to add listeners to events on such as which don't fire on . It also lets you use on . As with this element may only appear the top level of your component and must never be inside a block or element.","output":"<svelte:document onvisibilitychange={handleVisibilityChange} use:someAction />"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:body>: Similarly to this element allows you to add listeners to events on such as and which don't fire on .","input":"Similarly to this element allows you to add listeners to events on such as and which don't fire on . It also lets you use on the element. As with and this element may only appear the top level of your component and must never be inside a block or element.","output":"<svelte:body\n  onmouseenter={handleMouseenter}\n  onmouseleave={handleMouseleave}\n  use:someAction\n/>"}
{"instruction":"Create a Svelte 5 component demonstrating Stores: - when creating shared state, you can create a object containing the values you need and then manipulate said state","input":"- when creating shared state, you can create a object containing the values you need and then manipulate said state","output":"<script>\nimport { userState } from './state.svelte.js';\n</script>\n\n<p>User name: {userState.name}</p>\n\n<button onclick={() => { userState.name = 'new name'; }}>\n  change name\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...though note that if you instead of updating it, you will 'break the link' â€” in other words instead of this...","input":"...though note that if you instead of updating it, you will 'break the link' â€” in other words instead of this...","output":"<button onclick={() => counter = { count: 0 }}>\n  reset\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Context: ...you must do this:","input":"...you must do this:","output":"<button onclick={() =>counter.count = 0}>\n  reset\n</button>"}
{"instruction":"Write Svelte 5 code for Overview.","input":"Svelte 5 introduced some significant changes to Svelte's API, including and event attributes. As a result, some Svelte 3/4 features are deprecated (though supported for now, unless otherwise specified) and will eventually be removed. We recommend that you incrementally . The following pages document these features for","output":""}
{"instruction":"Write Svelte 5 code for export let.","input":"","output":"<!file: App.svelte>\n<script>\nimport Greeter from './Greeter.svelte';\n\nlet greeter;\n</script>\n\n<Greeter bind:this={greeter} />\n\n<button on:click={() => greeter.greet('world')}>\n  greet\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: Add to element event handlers with the character.","input":"Add to element event handlers with the character.","output":"<form on:submit|preventDefault={handleSubmit}>\n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: If the directive is used without a value, the component will the event, meaning that a consumer of the component can listen for it.","input":"If the directive is used without a value, the component will the event, meaning that a consumer of the component can listen for it.","output":"<button on:click>\n  The component itself will emit the click event\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: Components can dispatch events by creating a when they are initialised:","input":"Components can dispatch events by creating a when they are initialised:","output":"<script>\nimport { createEventDispatcher } from 'svelte';\n\nconst dispatch = createEventDispatcher();\n</script>\n\n<button on:click={() => dispatch('decrement')}>decrement</button>\n<button on:click={() => dispatch('increment')}>increment</button>"}
{"instruction":"Create a Svelte 5 component demonstrating on:: A consumer of this component can listen for the dispatched events:","input":"A consumer of this component can listen for the dispatched events:","output":"<script>\nimport Stepper from './Stepper.svelte';\n\nlet n = 0;\n</script>\n\n<Stepper\n  on:decrement={() => n -= 1}\n  on:increment={() => n += 1}\n/>\n\n<p>n: {n}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: In Svelte 5, content can be passed to components in the form of and rendered using .","input":"In Svelte 5, content can be passed to components in the form of and rendered using . In legacy mode, content inside component tags is considered which can be rendered by the component using a element:","output":"<!file: App.svelte>\n<script>\nimport Modal from './Modal.svelte';\n</script>\n\n<Modal>This is some slotted content</Modal>"}
{"instruction":"Write Svelte 5 code for <slot>.","input":"","output":"<!file: Modal.svelte>\n<div class=\"modal\">\n  <slot></slot>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: A component can have in addition to the default slot.","input":"A component can have in addition to the default slot. On the parent side, add a attribute to an element, component or directly inside the component tags.","output":"<!file: App.svelte>\n<script>\nimport Modal from './Modal.svelte';\n\nlet open = true;\n</script>\n\n{#if open}\n  <Modal>\n    This is some slotted content\n\n    <div slot=\"buttons\">\n      <button on:click={() => open = false}>\n        close\n      </button>\n    </div>\n  </Modal>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: On the child side, add a corresponding element:","input":"On the child side, add a corresponding element:","output":"<!file: Modal.svelte>\n<div class=\"modal\">\n  <slot></slot>\n  <hr>\n  <slot name=\"buttons\"></slot>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: If no slotted content is provided, a component can define fallback content by putting it inside the element:","input":"If no slotted content is provided, a component can define fallback content by putting it inside the element:","output":"<slot>\n  This will be rendered if no slotted content is provided\n</slot>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: Slots can be rendered zero or more times and can pass values to the parent using props.","input":"Slots can be rendered zero or more times and can pass values to the parent using props. The parent exposes the values to the slot template using the directive.","output":"<!file: FancyList.svelte>\n<ul>\n  {#each items as data}\n    <li class=\"fancy\">\n      <slot item={process(data)} />\n    </li>\n  {/each}\n</ul>"}
{"instruction":"Write Svelte 5 code for <slot>.","input":"","output":"<!file: App.svelte>\n<FancyList {items} let:item={processed}>\n  <div>{processed.text}</div>\n</FancyList>"}
{"instruction":"Create a Svelte 5 component demonstrating <slot>: Named slots can also expose values.","input":"Named slots can also expose values. The directive goes on the element with the attribute.","output":"<!file: FancyList.svelte>\n<ul>\n  {#each items as item}\n    <li class=\"fancy\">\n      <slot name=\"item\" item={process(data)} />\n    </li>\n  {/each}\n</ul>\n\n<slot name=\"footer\" />"}
{"instruction":"Write Svelte 5 code for <slot>.","input":"","output":"<!file: App.svelte>\n<FancyList {items}>\n  <div slot=\"item\" let:item>{item.text}</div>\n  <p slot=\"footer\">Copyright (c) 2019 Svelte Industries</p>\n</FancyList>"}
{"instruction":"Create a Svelte 5 component demonstrating $$slots: In runes mode, we know which were provided to a component, as they're just normal props.","input":"In runes mode, we know which were provided to a component, as they're just normal props. In legacy mode, the way to know if content was provided for a given slot is with the object, whose keys are the names of the slots passed into the component by the parent.","output":"<!file: Card.svelte>\n<div>\n  <slot name=\"title\" />\n  {#if $$slots.description}\n    <hr />\n    <slot name=\"description\" />\n  {/if}\n</div>"}
{"instruction":"Write Svelte 5 code for $$slots.","input":"","output":"<!file: App.svelte>\n<Card>\n  <h1 slot=\"title\">Blog Post Title</h1>\n</Card>"}
{"instruction":"Create a Svelte 5 component demonstrating <svelte:fragment>: The element allows you to place content in a without wrapping it in a container DOM element.","input":"The element allows you to place content in a without wrapping it in a container DOM element. This keeps the flow layout of your document intact.","output":"<!file: Widget.svelte>\n<div>\n  <slot name=\"header\">No header was provided</slot>\n  <p>Some content between header and footer</p>\n  <slot name=\"footer\" />\n</div>"}
{"instruction":"Write Svelte 5 code for <svelte:fragment>.","input":"","output":"<!file: App.svelte>\n<script>\nimport Widget from './Widget.svelte';\n</script>\n\n<Widget>\n  <h1 slot=\"header\">Hello</h1>\n  <svelte:fragment slot=\"footer\">\n    <p>All rights reserved.</p>\n    <p>Copyright (c) 2019 Svelte Industries</p>\n  </svelte:fragment>\n</Widget>"}
{"instruction":"Create a Svelte 5 component demonstrating Spring: A wrapper for a value that behaves in a spring-like fashion.","input":"A wrapper for a value that behaves in a spring-like fashion. Changes to will cause to move towards it over time, taking account of the and parameters.","output":"<script>\nimport { Spring } from 'svelte/motion';\n\nconst spring = new Spring(0);\n</script>\n\n<input type=\"range\" bind:value={spring.target} />\n<input type=\"range\" bind:value={spring.current} disabled />"}
{"instruction":"Create a Svelte 5 component demonstrating Tween: A wrapper for a value that tweens smoothly to its target value.","input":"A wrapper for a value that tweens smoothly to its target value. Changes to will cause to move towards it over time, taking account of the and options.","output":"<script>\nimport { Tween } from 'svelte/motion';\n\nconst tween = new Tween(0);\n</script>\n\n<input type=\"range\" bind:value={tween.target} />\n<input type=\"range\" bind:value={tween.current} disabled />"}
{"instruction":"Create a Svelte 5 component demonstrating SvelteURL: Svelte provides reactive versions of various built-ins like and .","input":"Svelte provides reactive versions of various built-ins like and . These can be imported from and used just like their native counterparts.","output":"<script>\nimport { SvelteURL } from 'svelte/reactivity';\n\nconst url = new SvelteURL('https://example.com/path');\n</script>\n\n<input bind:value={url.protocol} />\n<input bind:value={url.hostname} />\n<input bind:value={url.pathname} />\n\n<hr />\n\n<input bind:value={url.href} />"}
{"instruction":"Create a Svelte 5 component demonstrating Shallow routing: When shallow routing, you may want to render another inside the current page.","input":"When shallow routing, you may want to render another inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page. For this to work, you need to load the data that the expects. A convenient way to do this is to use inside the handler of an element. If the element (or a parent) uses the data will have already been requested, and will reuse that request.","output":"<!file: src/routes/photos/+page.svelte>\n<script>\nimport { preloadData, pushState, goto } from '$app/navigation';\nimport { page } from '$app/state';\nimport Modal from './Modal.svelte';\nimport PhotoPage from './[id]/+page.svelte';\n\nlet { data } = $props();\n</script>\n\n{#each data.thumbnails as thumbnail}\n  <a\n    href=\"/photos/{thumbnail.id}\"\n    onclick={async (e) => {\n      if (\n        innerWidth < 640 // bail if the screen is too small\n        || e.shiftKey // or the link is opened in a new window\n        || e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)\n        // should also consider clicking with a mouse scroll wheel\n      ) return;\n\n      // prevent navigation\n      e.preventDefault();\n\n      const { href } = e.currentTarget;\n\n      // run `load` functions (or rather, get the result of the `load` functions\n      // that are already running because of `data-sveltekit-preload-data`)\n      const result = await preloadData(href);\n\n      if (result.type === 'loaded' && result.status === 200) {\n        pushState(href, { selected: result.data });\n      } else {\n        // something bad happened! try navigating\n        goto(href);\n      }\n    }}\n  >\n    <img alt={thumbnail.alt} src={thumbnail.src} />\n  </a>\n{/each}\n\n{#if page.state.selected}\n  <Modal onclose={() => history.back()}>\n    <PhotoPage data={page.state.selected} />\n  </Modal>\n{/if}"}
{"instruction":"Create a Svelte 5 component demonstrating +server: By exporting handlers, files can be used to create a complete API:","input":"By exporting handlers, files can be used to create a complete API:","output":"<!file: src/routes/add/+page.svelte>\n<script>\nlet a = 0;\nlet b = 0;\nlet total = 0;\n\nasync function add() {\n  const response = await fetch('/api/add', {\n    method: 'POST',\n    body: JSON.stringify({ a, b }),\n    headers: {\n      'content-type': 'application/json'\n    }\n  });\n  total = await response.json();\n}\n</script>\n\n<input type=\"number\" bind:value={a}>\n+\n<input type=\"number\" bind:value={b}>\n=\n{total}\n\n<button onclick={add}>Calculate</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Customising use:enhance: To customise the behaviour, you can provide a that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the .","input":"To customise the behaviour, you can provide a that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the . Note that if you return a callback, the default behavior mentioned above is not triggered. To get it back, call .","output":"<form\n  method=\"POST\"\n  use:enhance={({ formElement, formData, action, cancel, submitter }) => {\n    // `formElement` is this `<form>` element\n    // `formData` is its `FormData` object that's about to be submitted\n    // `action` is the URL to which the form is posted\n    // calling `cancel()` will prevent the submission\n    // `submitter` is the `HTMLElement` that caused the form to be submitted\n\n    return async ({ result, update }) => {\n      // `result` is an `ActionResult` object\n      // `update` is a function which triggers the default logic that would be triggered if this callback wasn't set\n    };\n  }}\n>\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Custom event listener: We can also implement progressive enhancement ourselves, without with a normal event listener on the :","input":"We can also implement progressive enhancement ourselves, without with a normal event listener on the :","output":"<!file: src/routes/login/+page.svelte>\n<script>\nimport { invalidateAll, goto } from '$app/navigation';\nimport { applyAction, deserialize } from '$app/forms';\n\n/** @type {import('./$types').PageProps} */\nlet { form } = $props();\n\n/** @param {SubmitEvent & { currentTarget: EventTarget & HTMLFormElement}} event */\nasync function handleSubmit(event) {\n  event.preventDefault();\n  const data = new FormData(event.currentTarget);\n\n  const response = await fetch(event.currentTarget.action, {\n    method: 'POST',\n    body: data\n  });\n\n  /** @type {import('@sveltejs/kit').ActionResult} */\n  const result = deserialize(await response.text());\n\n  if (result.type === 'success') {\n    // rerun all `load` functions, following the successful update\n    await invalidateAll();\n  }\n\n  applyAction(result);\n}\n</script>\n\n<form method=\"POST\" onsubmit={handleSubmit}>\n  \n</form>"}
{"instruction":"Create a Svelte 5 component demonstrating Alternatives: Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use files to expose (for example) a JSON API.","input":"Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use files to expose (for example) a JSON API. Here's how such an interaction could look like:","output":"<!file: src/routes/send-message/+page.svelte>\n<script>\nfunction rerun() {\n  fetch('/api/ci', { method: 'POST' });\n}\n</script>\n\n<button onclick={rerun}>Rerun CI</button>"}
{"instruction":"Write Svelte 5 code for Manual invalidation.","input":"Note that can be a custom identifier that starts with :","output":"<!file: src/routes/random-number/+page.svelte>\n<script>\nimport { invalidate, invalidateAll } from '$app/navigation';\n\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\nfunction rerunLoadFunction() {\n  // any of these will cause the `load` function to rerun\n  invalidate('app:random');\n  invalidate('https://api.example.com/random-number');\n  invalidate(url => url.href.includes('random-number'));\n  invalidateAll();\n}\n</script>\n\n<p>random number: {data.number}</p>\n\n<button onclick={rerunLoadFunction}>Update random number</button>"}
{"instruction":"Write Svelte 5 code for How do I use the view transitions API?.","input":"For more, see on the Svelte blog.","output":""}
{"instruction":"Create a Svelte 5 component demonstrating Default slot bindings: Default slot bindings are no longer exposed to named slots and vice versa:","input":"Default slot bindings are no longer exposed to named slots and vice versa:","output":"<script>\nimport Nested from './Nested.svelte';\n</script>\n\n<Nested let:count>\n  <p>\n    count in default slot - is available: {count}\n  </p>\n  <p slot=\"bar\">\n    count in bar slot - is not available: {count}\n  </p>\n</Nested>"}
{"instruction":"Create a Svelte 5 component demonstrating export let â†’ $props: In Svelte 5, the rune makes this straightforward without any additional Svelte-specific syntax:","input":"In Svelte 5, the rune makes this straightforward without any additional Svelte-specific syntax:","output":"<script>\nlet klass = '';\nexport { klass as class};\n\nlet { class: klass, ...rest } = $props();\n</script>\n\n<button class={klass} {...$$restPropsrest}>click me</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Bubbling events: Instead of doing to 'forward' the event from the element to the component, the component should accept an callback prop:","input":"Instead of doing to 'forward' the event from the element to the component, the component should accept an callback prop:","output":"<script>\nlet { onclick } = $props();\n</script>\n\n<buttonon:click{onclick}>\n  click me\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Bubbling events: Note that this also means you can 'spread' event handlers onto the element along with other props instead of tediously forwarding each event separately:","input":"Note that this also means you can 'spread' event handlers onto the element along with other props instead of tediously forwarding each event separately:","output":"<script>\nlet props = $props();\n</script>\n\n<button{...$$props} on:click on:keydown on:all_the_other_stuff{...props}>\n  click me\n</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event modifiers: In Svelte 4, you can add event modifiers to handlers:","input":"In Svelte 4, you can add event modifiers to handlers:","output":"<button on:click|once|preventDefault={handler}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event modifiers: Since event handlers are just functions, you can create your own wrappers as necessary:","input":"Since event handlers are just functions, you can create your own wrappers as necessary:","output":"<script>\nfunction once(fn) {\n  return function (event) {\n    if (fn) fn.call(this, event);\n    fn = null;\n  };\n}\n\nfunction preventDefault(fn) {\n  return function (event) {\n    event.preventDefault();\n    fn.call(this, event);\n  };\n}\n</script>\n\n<button onclick={once(preventDefault(handler))}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Event modifiers: For we add the modifier to the event name:","input":"For we add the modifier to the event name:","output":"<button onclickcapture={...}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Multiple event handlers: In Svelte 4, this is possible:","input":"In Svelte 4, this is possible:","output":"<button on:click={one} on:click={two}>...</button>"}
{"instruction":"Create a Svelte 5 component demonstrating Multiple event handlers: Duplicate attributes/properties on elements â€” which now includes event handlers â€” are not allowed.","input":"Duplicate attributes/properties on elements â€” which now includes event handlers â€” are not allowed. Instead, do this:","output":"<button onclick={(e) => {\n    one(e);\n    two(e);\n  }}\n>\n  ...\n</button>"}