{"instruction":"Create a Svelte 5 component demonstrating $effect: You can create an effect with the rune ( ):","input":"You can create an effect with the rune ( ):","output":"<script>\nlet size = $state(50);\nlet color = $state('#ff3e00');\nlet canvas;\n\n$effect(() => {\n  const context = canvas.getContext('2d');\n  context.clearRect(0, 0, canvas.width, canvas.height);\n\n  // this will re-run whenever `color` or `size` change\n  context.fillStyle = color;\n  context.fillRect(0, 0, size, size);\n});\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\"></canvas>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: An effect can return a which will run immediately before the effect re-runs ( ):","input":"An effect can return a which will run immediately before the effect re-runs ( ):","output":"<script>\nlet count = $state(0);\nlet milliseconds = $state(1000);\n\n$effect(() => {\n  // This will be recreated whenever `milliseconds` changes\n  const interval = setInterval(() => {\n    count += 1;\n  }, milliseconds);\n\n  return () => {\n    // if a teardown function is provided, it will run\n    // a) immediately before the effect re-runs\n    // b) when the component is destroyed\n    clearInterval(interval);\n  };\n});\n</script>\n\n<h1>{count}</h1>\n\n<button onclick={() => (milliseconds *= 2)}>slower</button>\n<button onclick={() => (milliseconds /= 2)}>faster</button>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: An effect only reruns when the object it reads changes, not when a property inside it changes.","input":"An effect only reruns when the object it reads changes, not when a property inside it changes. (If you want to observe changes an object at dev time, you can use .)","output":"<script>\nlet state = $state({ value: 0 });\nlet derived = $derived({ value: state.value * 2 });\n\n// this will run once, because `state` is never reassigned (only mutated)\n$effect(() => {\n  state;\n});\n\n// this will run whenever `state.value` changes...\n$effect(() => {\n  state.value;\n});\n\n// ...and so will this, because `derived` is a new object each time\n$effect(() => {\n  derived;\n});\n</script>\n\n<button onclick={() => (state.value += 1)}>\n  {state.value}\n</button>\n\n<p>{state.value} doubled is {derived.value}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect.pre: In rare cases, you may need to run code the DOM updates.","input":"In rare cases, you may need to run code the DOM updates. For this we can use the rune:","output":"<script>\nimport { tick } from 'svelte';\n\nlet div = $state();\nlet messages = $state([]);\n\n// ...\n\n$effect.pre(() => {\n  if (!div) return; // not yet mounted\n\n  // reference `messages` array length so that this code re-runs whenever it changes\n  messages.length;\n\n  // autoscroll when new messages are added\n  if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n    tick().then(() => {\n      div.scrollTo(0, div.scrollHeight);\n    });\n  }\n});\n</script>\n\n<div bind:this={div}>\n  {#each messages as message}\n    <p>{message}</p>\n  {/each}\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect.tracking: The rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template ( ):","input":"The rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template ( ):","output":"<script>\nconsole.log('in component setup:', $effect.tracking()); // false\n\n$effect(() => {\n  console.log('in effect:', $effect.tracking()); // true\n});\n</script>\n\n<p>in template: {$effect.tracking()}</p>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: Instead of this...","input":"Instead of this...","output":"<script>\nlet count = $state(0);\nlet doubled = $state();\n\n// don't do this!\n$effect(() => {\n  doubled = count * 2;\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: ...do this:","input":"...do this:","output":"<script>\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: You might be tempted to do something convoluted with effects to link one value to another.","input":"You might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for \"money spent\" and \"money left\" that are connected to each other. If you update one, the other should update accordingly. Don't use effects for this ( ):","output":"<script>\nlet total = 100;\nlet spent = $state(0);\nlet left = $state(total);\n\n$effect(() => {\n  left = total - spent;\n});\n\n$effect(() => {\n  spent = total - left;\n});\n</script>\n\n<label>\n  <input type=\"range\" bind:value={spent} max={total} />\n  {spent}/{total} spent\n</label>\n\n<label>\n  <input type=\"range\" bind:value={left} max={total} />\n  {left}/{total} left\n</label>"}
{"instruction":"Create a Svelte 5 component demonstrating $effect: Instead, use callbacks or — better still — where possible ( ):","input":"Instead, use callbacks or — better still — where possible ( ):","output":"<script>\nlet total = 100;\nlet spent = $state(0);\nlet left = $state(total);\n\nfunction updateSpent(value) {\n  spent = value;\n  left = total - spent;\n}\n\nfunction updateLeft(value) {\n  left = value;\n  spent = total - left;\n}\n</script>\n\n<label>\n  <input type=\"range\" bind:value={() => spent, updateSpent} max={total} />\n  {spent}/{total} spent\n</label>\n\n<label>\n  <input type=\"range\" bind:value={() => left, updateLeft} max={total} />\n  {left}/{total} left\n</label>"}
{"instruction":"Create a Svelte 5 component demonstrating $inspect.trace(...): This rune, added in 5.14, causes the surrounding function to be in development.","input":"This rune, added in 5.14, causes the surrounding function to be in development. Any time the function re-runs as part of an or a information will be printed to the console about which pieces of reactive state caused the effect to fire.","output":"<script>\nimport { doSomeWork } from './elsewhere';\n\n$effect(() => {\n  $inspect.trace();\n  doSomeWork();\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating bind:: To get a reference to a DOM node, use .","input":"To get a reference to a DOM node, use . The value will be until the component is mounted — in other words, you should read it inside an effect or an event handler, but not during component initialisation:","output":"<script>\n/** @type {HTMLCanvasElement} */\nlet canvas;\n\n$effect(() => {\n  const ctx = canvas.getContext('2d');\n  drawStuff(ctx);\n});\n</script>\n\n<canvas bind:this={canvas}></canvas>"}
{"instruction":"Create a Svelte 5 component demonstrating use:: Actions are functions that are called when an element is mounted.","input":"Actions are functions that are called when an element is mounted. They are added with the directive, and will typically use an so that they can reset any state when the element is unmounted:","output":"<!file: App.svelte>\n<script>\n/** @type {import('svelte/action').Action} */\nfunction myaction(node) {\n  // the node has been mounted in the DOM\n\n  $effect(() => {\n    // setup goes here\n\n    return () => {\n      // teardown goes here\n    };\n  });\n}\n</script>\n\n<div use:myaction>...</div>"}
{"instruction":"Create a Svelte 5 component demonstrating use:: The interface receives three optional type arguments — a node type (which can be if the action applies to everything), a parameter, and any custom event handlers created by the action:","input":"The interface receives three optional type arguments — a node type (which can be if the action applies to everything), a parameter, and any custom event handlers created by the action:","output":"<!file: App.svelte>\n<script>\n/**\n * @type {import('svelte/action').Action<\n * HTMLDivElement,\n * undefined,\n * {\n * onswiperight: (e: CustomEvent) => void;\n * onswipeleft: (e: CustomEvent) => void;\n * // ...\n * }\n * >}\n */\nfunction gestures(node) {\n  $effect(() => {\n    // ...\n    node.dispatchEvent(new CustomEvent('swipeleft'));\n    // ...\n    node.dispatchEvent(new CustomEvent('swiperight'));\n  });\n}\n</script>\n\n<div use:gestures onswipeleft={next} onswiperight={prev}>\n  ...\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: The function schedules a callback to run as soon as the component has been mounted to the DOM.","input":"The function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live the component; it can be called from an external module). does not run inside a component that is rendered on the server.","output":"<script>\nimport { onMount } from 'svelte';\n\nonMount(() => {\n  console.log('the component has mounted');\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: If a function is returned from it will be called when the component is unmounted.","input":"If a function is returned from it will be called when the component is unmounted.","output":"<script>\nimport { onMount } from 'svelte';\n\nonMount(() => {\n  const interval = setInterval(() => {\n    console.log('beep');\n  }, 1000);\n\n  return () => clearInterval(interval);\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: Schedules a callback to run immediately before the component is unmounted.","input":"Schedules a callback to run immediately before the component is unmounted. Out of and this is the only one that runs inside a server-side component.","output":"<script>\nimport { onDestroy } from 'svelte';\n\nonDestroy(() => {\n  console.log('the component is being destroyed');\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: While there's no \"after update\" hook, you can use to ensure that the UI is updated before continuing.","input":"While there's no \"after update\" hook, you can use to ensure that the UI is updated before continuing. returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.","output":"<script>\nimport { tick } from 'svelte';\n\n$effect.pre(() => {\n  console.log('the component is about to update');\n  tick().then(() => {\n    console.log('the component just updated');\n  });\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: Svelte 4 contained hooks that ran before and after the component as a whole was updated.","input":"Svelte 4 contained hooks that ran before and after the component as a whole was updated. For backwards compatibility, these hooks were shimmed in Svelte 5 but not available inside components that use runes.","output":"<script>\nimport { beforeUpdate, afterUpdate } from 'svelte';\n\nbeforeUpdate(() => {\n  console.log('the component is about to update');\n});\n\nafterUpdate(() => {\n  console.log('the component just updated');\n});\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Lifecycle hooks: To implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were scrolled to the bottom), we need to measure the DOM before we update it.","input":"To implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were scrolled to the bottom), we need to measure the DOM before we update it. In Svelte 4, we do this with but this is a flawed approach — it fires before update, whether it's relevant or not. In the example below, we need to introduce checks like to make sure we don't mess with the scroll position when someone toggles dark mode. With runes, we can use which behaves the same as but runs before the DOM is updated. As long as we explicitly reference inside the effect body, it will run whenever changes, but when changes. and its equally troublesome counterpart are therefore deprecated in Svelte 5.","output":"<script>\nimport {beforeUpdate, afterUpdate,tick } from 'svelte';\n\nlet updatingMessages = false;\nlet theme =$state('dark');\nlet messages =$state([]);\nlet viewport;\n\nbeforeUpdate(() => {\n$effect.pre(() => {\n  if (!updatingMessages) return;\n  messages;\n\n  const autoscroll =\n    viewport &&\n    viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\n  if (autoscroll) {\n    tick().then(() => {\n      viewport.scrollTo(0, viewport.scrollHeight);\n    });\n  }\n  updatingMessages = false;\n});\n\nfunction handleKeydown(event) {\n  if (event.key === 'Enter') {\n    const text = event.target.value;\n    if (!text) return;\n\n    updatingMessages = true;\n    messages = [...messages, text];\n    event.target.value = '';\n  }\n}\n\nfunction toggle() {\n  theme = theme === 'dark' ? 'light' : 'dark';\n}\n</script>\n\n<div class:dark={theme === 'dark'}>\n  <div bind:this={viewport}>\n    {#each messages as message}\n      <p>{message}</p>\n    {/each}\n  </div>\n\n  <inputonkeydown={handleKeydown} />\n  <buttononclick={toggle}>\n    Toggle dark mode\n  </button>\n</div>"}
{"instruction":"Create a Svelte 5 component demonstrating Component and page state is preserved: ...then navigating from to won't cause the layout, page and any other components within to be destroyed and recreated.","input":"...then navigating from to won't cause the layout, page and any other components within to be destroyed and recreated. Instead the prop (and by extension and ) will update (as it would with any other Svelte component) and, because the code isn't rerunning, lifecycle methods like and won't rerun and won't be recalculated. Instead, we need to make the value :","output":"<script>\n/** @type {import('./$types').PageProps} */\nlet { data } = $props();\n\nlet wordCount = $derived(data.content.split(' ').length);\nlet estimatedReadingTime = $derived(wordCount / 250);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating Component and page state is preserved: Reusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values.","input":"Reusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:","output":"<script>\nimport { page } from '$app/state';\n</script>\n\n{#key page.url.pathname}\n  <BlogPost title={data.title} content={data.title} />\n{/key}"}
{"instruction":"Create a Svelte 5 component demonstrating $: → $derived/$effect: In Svelte 4, a statement at the top level of a component could be used to declare a derivation, i.e.","input":"In Svelte 4, a statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the rune:","output":"<script>\nlet count = $state(0);\n$:constdouble =$derived(count * 2);\n</script>"}
{"instruction":"Create a Svelte 5 component demonstrating $: → $derived/$effect: A statement could also be used to create side effects.","input":"A statement could also be used to create side effects. In Svelte 5, this is achieved using the rune:","output":"<script>\nlet count = $state(0);\n\n$:$effect(() =>{\n  if (count > 5) {\n    alert('Count is too high!');\n  }\n});\n</script>"}