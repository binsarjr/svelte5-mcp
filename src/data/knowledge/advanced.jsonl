{"question":"How do you conditionally render content in Svelte?","answer":"Content in Svelte can be conditionally rendered using an `{#if ...}` block. [cite: 244]\n\nFor example:\n```svelte\n{#if answer === 42}\n\t<p>what was the question?</p>\n{/if}\n```\nAdditional conditions can be added using `{:else if expression}`, and an optional `{:else}` clause can be included. [cite: 245]\n\nExample with multiple conditions:\n```svelte\n{#if porridge.temperature > 100}\n\t<p>too hot!</p>\n{:else if 80 > porridge.temperature}\n\t<p>too cold!</p>\n{:else}\n\t<p>just right!</p>\n{/if}\n```\nBlocks can wrap both elements and text within elements."}
{"question":"What is the purpose of `{#key ...}` blocks in Svelte?","answer":"The `{#key ...}` block in Svelte is used to destroy and recreate its contents whenever the value of its expression changes. [cite: 252] This is particularly useful for re-instantiating components or replaying transitions when a value changes.\n\nFor example, to re-instantiate a component:\n```svelte\n{#key value}\n\t<Component />\n{/key}\n```\nOr to replay a transition:\n```svelte\n{#key value}\n\t<div transition:fade>{value}</div>\n{/key}\n```"}
{"question":"How do you render snippets in Svelte?","answer":"To render a snippet in Svelte, you use the `{@render ...}` tag. [cite: 279]\n\nExample:\n```svelte\n{#snippet sum(a, b)}\n\t<p>{a} + {b} = {a + b}</p>\n{/snippet}\n\n{@render sum(1, 2)}\n{@render sum(3, 4)}\n{@render sum(5, 6)}\n```\nThe expression within `{@render ...}` can be a simple identifier (like `sum`) or an arbitrary JavaScript expression. [cite: 279]\n\n**Optional Snippets**: If a snippet is potentially `undefined` (e.g., an incoming prop), you can use optional chaining (`{@render children?.()}`) to render it only when it's defined. [cite: 279] Alternatively, an `{#if ...}` block with an `{:else}` clause can be used to render fallback content. [cite: 279]"}
{"question":"How do you inject raw HTML into a Svelte component?","answer":"To inject raw HTML into a Svelte component, you use the `{@html ...}` tag. [cite: 279]\n\nExample:\n```svelte\n<article>\n\t{@html content}\n</article>\n```\nThe expression provided to `{@html}` should be valid standalone HTML; it will not work with incomplete tags like `<div>` followed by `</div>` in separate `{@html}` tags. [cite: 280] Also, Svelte code within `{@html}` will not be compiled. [cite: 281]\n\n**Styling**: Content rendered with `{@html}` is 'invisible' to Svelte's scoping mechanisms and will not receive scoped styles directly. [cite: 281] Any styles for elements within the injected HTML will be regarded as unused by the compiler. [cite: 281] To style such content, you need to use the `:global` modifier to target elements inside the container. [cite: 281]\n\nExample:\n```svelte\n<style>\n\tarticle:global{\n\t\ta { color: hotpink }\n\t\timg { width: 100% }\n\t}\n</style>\n```"}
{"question":"How do you define local constants in Svelte templates?","answer":"The `{@const ...}` tag in Svelte is used to define a local constant within a template. [cite: 282]\n\nExample:\n```svelte\n{#each boxes as box}\n\t{@const area = box.width * box.height}\n\t{box.width} * {box.height} = {area}\n{/each}\n```\n`{@const}` is only permitted as an immediate child of a block (such as `{#if ...}`, `{#each ...}`, `{#snippet ...}`), a `<Component />`, or a `<svelte:boundary>`. [cite: 283]"}
{"question":"How does `{@debug ...}` work in Svelte?","answer":"The `{@debug ...}` tag in Svelte serves as an alternative to `console.log(...)`. [cite: 284] It logs the values of specified variables whenever they change and pauses code execution if your developer tools are open. [cite: 285]\n\nExample:\n```svelte\n<script>\n\tlet user = {\n\t\tfirstname: 'Ada',\n\t\tlastname: 'Lovelace'\n\t};\n</script>\n\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>\n```\n`{@debug ...}` accepts a comma-separated list of variable names; it does not support arbitrary expressions. [cite: 286] A `{@debug}` tag without any arguments will insert a `debugger` statement that triggers when *any* state changes, not just specified variables. [cite: 287]"}
{"question":"How do you handle reduced motion in Svelte transitions?","answer":"For accessibility, it's important to respect user preferences for reduced motion. You can disable transitions for users who have this preference enabled in their operating system by using a `@media` query in your CSS. [cite: svelte.dev/blog/view-transitions]\n\nExample:\n```css\n@media (prefers-reduced-motion) {\n\t::view-transition-group(*),\n\t::view-transition-old(*),\n\t::view-transition-new(*) {\n\t\tanimation: none !important;\n\t}\n}\n```"}
{"question":"How do you use animations in Svelte?","answer":"Animations in Svelte are triggered when the contents of a [keyed each block](#Keyed-each-blocks) are re-ordered. [cite: 364] Animations do not run when an element is added or removed, only when the index of an existing data item changes within the block. [cite: 365] Animate directives must be placed on an element that is an *immediate* child of a keyed each block. [cite: 366]\n\nAnimations can be used with Svelte's [built-in animation functions](docs/svelte/svelte-animate) or custom animation functions. [cite: 367]\n\nExample:\n```svelte\n\n{#each list as item, index (item)}\n\t<li animate:flip>{item}</li>\n{/each}\n```\n\n**Animation Parameters**: Similar to actions and transitions, animations can accept parameters. [cite: 368]\n```svelte\n{#each list as item, index (item)}\n\t<li animate:flip={{ delay: 500 }}>{item}</li>\n{/each}\n```\n\n**Custom Animation Functions**: Custom animation functions are called with the `node`, an `animation` object (containing `from` and `to` `DOMRect` properties describing the element's start and end geometries), and any `parameters`. [cite: 369, 370, 371]\n\nIf the returned object from a custom animation function includes a `css` method, Svelte will create a web animation. [cite: 372] The `t` argument in `css` goes from `0` to `1` after easing, and `u` is `1 - t`. [cite: 373] The function is called repeatedly before the animation begins. [cite: 374]\n\nExample of a custom animation with a `css` function:\n```svelte\n<!file: App.svelte>\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect;\n\t * to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\tcss: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}\n```\nA custom animation function can also return a `tick` function, which is called during the animation with the same `t` and `u` arguments. [cite: 379]\n\nExample of a custom animation with a `tick` function:\n```svelte\n<!file: App.svelte>\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect;\n\t * to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\ttick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}\n```"}
{"question":"How do you apply styles with the `style:` directive in Svelte?","answer":"The `style:` directive in Svelte provides a shorthand for setting multiple styles on an element. [cite: 384]\n\nExample:\n```svelte\n\n<div style:color=\"red\">...</div>\n<div style=\"color: red;\">...</div>\n```\nThe value can contain arbitrary expressions: [cite: 384]\n```svelte\n<div style:color={myColor}>...</div>\n```\nThe shorthand form is also allowed: [cite: 384]\n```svelte\n<div style:color>...</div>\n```\nMultiple styles can be set on a single element: [cite: 385]\n```svelte\n<div style:color style:width=\"12rem\" style:background-color={darkMode ?\n'black' : 'white'}>...</div>\n```\nTo mark a style as important, use the `|important` modifier: [cite: 385]\n```svelte\n<div style:color|important=\"red\">...</div>\n```\nWhen `style:` directives are combined with `style` attributes, the directives take precedence. [cite: 386]\n```svelte\n<div style=\"color: blue;\"\nstyle:color=\"red\">This will be red</div>\n```"}
{"question":"How does Svelte handle scoped styles?","answer":"Svelte components can include a `<style>` element that contains CSS specifically for that component. [cite: 400] By default, this CSS is *scoped*, meaning it will only apply to elements within the component and not to other elements on the page. [cite: 401] Svelte achieves this by adding a unique class (e.g., `svelte-123xyz`) based on a hash of the component's styles to the affected elements. [cite: 402]\n\nExample:\n```svelte\n<style>\n\tp {\n\t\t/* this will only affect <p> elements in this component */\n\t\tcolor: burlywood;\n\t}\n</style>\n```\n\n**Specificity**: Each scoped selector gains a specificity increase of 0-1-0 due to the addition of the scoping class. [cite: 404] This ensures that a `p` selector defined within a component takes precedence over a `p` selector in a global stylesheet, even if the global stylesheet is loaded later. [cite: 405] In some cases, the scoping class is added multiple times, but after the first instance, it's added with `:where(.svelte-xyz123)` to avoid further increasing specificity. [cite: 406]\n\n**Scoped Keyframes**: If a component defines `@keyframes`, their names are also scoped to the component using the same hashing mechanism. [cite: 407] Any `animation` rules within the component are adjusted accordingly. [cite: 408]"}
{"question":"How do you apply global styles in Svelte?","answer":"Svelte provides mechanisms to apply styles globally, overriding the default component-scoped behavior.\n\n**`:global(...)` modifier**: To apply styles to a single selector globally, use the `:global(...)` modifier: [cite: 409]\n```svelte\n<style>\n\t:global(body) {\n\t\t/* applies to <body> */\n\t\tmargin: 0;\n\t}\n\n\tdiv :global(strong) {\n\t\t/* applies to all <strong> elements, in any component,\n\t\t   that are inside <div> elements belonging\n\t\t   to this component */\n\t\tcolor: goldenrod;\n\t}\n\n\tp:global(.big.red) {\n\t\t/* applies to all <p> elements belonging to this component\n\t\t   with `class=\"big red\"`, even if it is applied\n\t\t   programmatically (for example by a library) */\n\t}\n</style>\n```\nFor `@keyframes` to be accessible globally, prepend their names with `-global-`; this prefix will be removed during compilation. [cite: 411, 412]\n\n**`:global` block**: To apply styles to a group of selectors globally, create a `:global {...}` block: [cite: 410]\n```svelte\n<style>\n\t:global {\n\t\t/* applies to every <div> in your application */\n\t\tdiv { ... }\n\n\t\t/* applies to every <p> in your application */\n\t\tp { ... }\n\t}\n\n\t.a :global {\n\t\t/* applies to every `.b .c .d` element, in any component,\n\t\t   that is inside an `.a` element in this component */\n\t\t.b .c .d {...}\n\t}\n</style>\n```"}
{"question":"How do you use CSS custom properties in Svelte?","answer":"Svelte allows you to pass both static and dynamic CSS custom properties to components. [cite: 413]\n\nExample:\n```svelte\n<Slider\n\tbind:value\n\tmin={0}\n\tmax={100}\n\t--track-color=\"black\"\n\t--thumb-color=\"rgb({r} {g} {b})\"\n/>\n```\nThis code essentially translates to wrapping the component in a `svelte-css-wrapper` element (or a `<g>` for SVG elements) with the custom properties set as inline styles. [cite: 413, 414]\n\nInside the component, these custom properties can be read using `var(...)`, with the option to provide fallback values: [cite: 414]\n```svelte\n<style>\n\t.track {\n\t\tbackground: var(--track-color, #aaa);\n\t}\n\n\t.thumb {\n\t\tbackground: var(--thumb-color, blue);\n\t}\n</style>\n```\nCustom properties don't strictly need to be specified directly on the component; they can be defined on any parent element (e.g., the `:root` element in a global stylesheet) and still be accessible within the component. [cite: 414]"}
{"question":"Can you nest `<style>` elements in Svelte?","answer":"While a Svelte component can only have one top-level `<style>` tag, it is possible to nest `<style>` tags inside other elements or logic blocks. [cite: 415]\n\nWhen a `<style>` tag is nested, it is inserted directly into the DOM as-is, meaning no scoping or processing will be applied to it. [cite: 416, 417]\n\nExample:\n```svelte\n<div>\n\t<style>\n\t\t/* this style tag will be inserted as-is */\n\t\tdiv {\n\t\t\t/* this will apply to all `<div>` elements in the DOM */\n\t\t\tcolor: red;\n\t\t}\n\t</style>\n</div>\n```"}
{"question":"What is the Svelte Store contract?","answer":"You can create custom stores in Svelte without relying on `svelte/store` by adhering to the *store contract*: [cite: 512]\n\n1.  **`.subscribe` method**: A store must have a `.subscribe` method that accepts a subscription function as its argument. [cite: 512] This subscription function must be called immediately and synchronously with the store's current value upon calling `.subscribe`. [cite: 513] All active subscription functions must then be called synchronously whenever the store's value changes. [cite: 514]\n2.  **Unsubscribe function**: The `.subscribe` method must return an unsubscribe function. Calling this function must stop its corresponding subscription, preventing further calls to its subscription function. [cite: 515]\n3.  **Optional `.set` method**: A store *may optionally* include a `.set` method. [cite: 516] If present, it must accept a new value for the store and synchronously call all active subscription functions. [cite: 516] Such a store is known as a *writable store*. [cite: 516]\n\nFor interoperability with RxJS Observables, the `.subscribe` method can also return an object with an `.unsubscribe` method, rather than the function directly. [cite: 517] However, if `.subscribe` does not synchronously call the subscription (which is not required by the Observable spec), Svelte will consider the store's value as `undefined` until it does. [cite: 518]"}
{"question":"What are Svelte 5 compilation and bundle optimization strategies?","answer":"Svelte 5 provides several compilation and bundle optimization strategies. **Compile-time Optimizations**: Automatic dead code elimination, Component tree shaking, CSS purging and optimization, Static analysis for reactive dependencies, Ahead-of-time template compilation. **Bundle Size Strategies**: Dynamic imports for code splitting: `const Component = await import('./Component.svelte')`, Route-based splitting in SvelteKit, Lazy loading of non-critical components, Tree shaking of unused library code. **CSS Optimization**: Scoped CSS by default (no CSS-in-JS runtime overhead), Automatic unused CSS removal, CSS bundling and minification, Critical CSS extraction. **Advanced Techniques**: Use `@sveltejs/enhanced-img` for automatic image optimization, Implement service worker caching strategies, Optimize font loading with `font-display: swap`, Use component-level code splitting. **Build Configuration**: Configure Vite for optimal bundling, Enable Rollup optimizations, Use proper source maps for debugging, Implement compression (gzip/brotli). **Performance Benefits**: 25%+ smaller bundles compared to virtual DOM frameworks, Faster initial load times, No runtime framework overhead, Efficient update mechanisms. These strategies leverage Svelte compiler-first philosophy to deliver optimal performance with minimal configuration."}