{"question":"How do you iterate over lists in Svelte?","answer":"Svelte uses `{#each ...}` blocks to iterate over lists of values. [cite: 246] These values can be arrays, array-like objects (those with a `length` property), or iterables like `Map` and `Set` (anything usable with `Array.from`). [cite: 247]\n\nSimple iteration:\n```svelte\n<h1>Shopping list</h1>\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\nAn optional `index` can also be specified:\n```svelte\n{#each items as item, i}\n\t<li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}\n```\n\n**Keyed Each Blocks**: Providing a *key* expression (which must uniquely identify each list item) allows Svelte to efficiently diff the list when data changes, rather than adding or removing items from the end. [cite: 248] Strings and numbers are recommended for keys. [cite: 249]\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n\n\n{#each items as item, i (item.id)}\n\t<li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}\n```\nDestructuring and rest patterns can be freely used within `each` blocks. [cite: 250]\n\n**Each Blocks Without an Item**: To render something `n` times without needing an item variable, you can omit the `as` part. [cite: 251]\n\n**Else Blocks**: An `{#each ...}` block can include an `{:else}` clause, which renders if the list is empty. [cite: 251]\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n```"}
{"question":"How do you handle service workers in SvelteKit?","answer":"SvelteKit provides a simple way to add a service worker to your application. You can create a `src/service-worker.js` file to define your service worker's behavior, such as caching strategies for offline access. The service worker can intercept `fetch` events and respond with cached assets or network requests. [cite: svelte.dev/docs/kit/service-workers]\n\nExample of a caching strategy in a service worker:\n```javascript\nimport { build, files, version } from '$service-worker';\n\nconst CACHE = `cache-${version}`;\n\nconst ASSETS = [\n  ...build, // assets generated by Vite\n  ...files  // assets in your static directory\n];\n\nself.addEventListener('install', (event) => {\n\tasync function addFilesToCache() {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t}\n\n\tevent.waitUntil(addFilesToCache());\n});\n\nself.addEventListener('activate', (event) => {\n\tasync function deleteOldCaches() {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t}\n\n\tevent.waitUntil(deleteOldCaches());\n});\n\nself.addEventListener('fetch', (event) => {\n\tif (event.request.method !== 'GET') return;\n\n\tasync function respond() {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\treturn cache.match(url.pathname);\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\n\t\t\tif (response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (err) {\n\t\t\treturn cache.match(event.request);\n\t\t}\n\t}\n\n\tevent.respondWith(respond());\n});\n```"}