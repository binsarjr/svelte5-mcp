{"question":"What is Svelte?","answer":"Svelte is a framework for building user interfaces on the web. It utilizes a compiler to transform declarative components written in HTML, CSS, and JavaScript into optimized JavaScript. [cite: 1, 3] This allows Svelte to be used for building various web applications, from standalone components to full-stack applications with SvelteKit. [cite: 4] For new users, it is recommended to start with the interactive tutorial and refer to the documentation for questions. [cite: 5] Svelte can also be tried online in the playground or on StackBlitz for a more fully-featured environment. [cite: 6]"}
{"question":"How do you get started with Svelte?","answer":"The recommended way to get started with Svelte is by using SvelteKit, its official application framework, which is powered by Vite. [cite: 7, 8] You can create a new project by running `npx sv create myapp`, navigating into the directory with `cd myapp`, installing dependencies with `npm install`, and running the development server with `npm run dev`. [cite: 9] New Svelte users can initially focus on Svelte itself and explore SvelteKit's features later. [cite: 10]\n\nAlternatively, Svelte can be used directly with Vite by running `npm create vite@latest` and selecting the `svelte` option. [cite: 11] This setup uses `vite-plugin-svelte` to generate HTML, JS, and CSS files in the `dist` directory upon building. [cite: 12] In most cases, you would also need to choose a routing library. [cite: 13] While Vite is often used for single-page applications (SPAs), SvelteKit can also build SPAs. [cite: 14] Other build tool plugins exist for Rollup and Webpack, but Vite is recommended. [cite: 15]"}
{"question":"What are `.svelte` files?","answer":"`.svelte` files are where components, the building blocks of Svelte applications, are written. [cite: 20] These files use a superset of HTML and can optionally include script, style, and markup sections. [cite: 21]\n\nScript blocks (`<script>`) contain JavaScript (or TypeScript with `lang=\"ts\"`) that executes when a component instance is created. [cite: 23] Top-level variables and imports within this block can be referenced in the component's markup. [cite: 24] Svelte 5 introduces *runes* like `$props` and reactivity features within script blocks, which are keywords with a `$` prefix and behave differently from normal JavaScript functions. [cite: 25, 39, 40]\n\nScript modules (`<script module>`) run once when the module is first evaluated, not for each component instance. [cite: 26] Variables declared here can be referenced elsewhere in the component, but not vice-versa. [cite: 27] Bindings can be exported from this block, but `export default` is not allowed as the default export is the component itself. [cite: 29, 30] This module-level script concept was introduced in Svelte 5 as `<script module>`, replacing the Svelte 4 syntax of `<script context=\"module\">`. [cite: 26, 30]\n\nStyle blocks (`<style>`) contain CSS that is scoped to that specific component by default, ensuring styles do not affect elements outside the component. [cite: 31, 32]"}
{"question":"What are `.svelte.js` and `.svelte.ts` files?","answer":"In addition to `.svelte` files, Svelte also supports `.svelte.js` and `.svelte.ts` files. [cite: 33] These files function like standard `.js` or `.ts` modules, but they uniquely allow the use of runes. [cite: 34] This capability is beneficial for creating reusable reactive logic or sharing reactive state across your application. [cite: 34] However, note that reassigned state cannot be exported from these files. [cite: 34] This file type is a new concept introduced in Svelte 5. [cite: 35]"}
{"question":"What are runes in Svelte?","answer":"Runes are symbols used in `.svelte` and `.svelte.js`/`.svelte.ts` files that control the Svelte compiler. [cite: 37] They are considered part of the Svelte language syntax, acting as keywords. [cite: 38] Runes are prefixed with a `$` and appear similar to functions, for example, `$state('hello')`. [cite: 39, 40]\n\nKey differences from normal JavaScript functions include: [cite: 40]\n* They do not need to be imported. [cite: 40]\n* They are not values, meaning they cannot be assigned to variables or passed as arguments. [cite: 40]\n* They are only valid in specific positions, similar to JavaScript keywords, and the compiler will assist if they are placed incorrectly. [cite: 40]\n\nRunes were introduced in Svelte 5. [cite: 40]"}
{"question":"What are stores in Svelte and when should they be used?","answer":"A *store* in Svelte is an object that provides reactive access to a value through a defined *store contract*. [cite: 455] The `svelte/store` module offers minimal store implementations that fulfill this contract. [cite: 456]\n\nInside a component, you can access a store's value by prefixing its variable name with a `$` (e.g., `$count`). [cite: 457] This prefix triggers Svelte to declare the variable, subscribe to the store during component initialization, and unsubscribe when appropriate. [cite: 458] Assignments to `$`-prefixed variables that are writable stores will result in a call to the store's `.set` method. [cite: 459] Stores must be declared at the top level of a component. [cite: 460] Local variables that do not represent store values must *not* have a `$` prefix. [cite: 460]\n\nExample:\n```svelte\n<script>\n\timport { writable } from 'svelte/store';\n\tconst count = writable(0);\n\tconsole.log($count); // logs 0\n\n\tcount.set(1);\n\tconsole.log($count); // logs 1\n\n\t$count = 2;\n\tconsole.log($count); // logs 2\n</script>\n```\n\n**When to use stores**: Prior to Svelte 5, stores were the primary solution for cross-component reactive states or extracting logic. [cite: 463] With the introduction of runes, these use cases have diminished. [cite: 463]\n\n* **Extracting logic**: Runes' universal reactivity is now preferred, allowing you to use runes outside of components (in `.svelte.js` or `.svelte.ts` files). [cite: 463]\n* **Creating shared state**: You can create a `$state` object with the necessary values and manipulate it directly. [cite: 464]\n\nExample of shared state with `$state` in `.svelte.js`:\n```ts\n/// file: state.svelte.js\nexport const userState = $state({\n\tname: 'name',\n\t/* ... */\n});\n```\nThen in `App.svelte`:\n```svelte\n<!file: App.svelte>\n<script>\n\timport { userState } from './state.svelte.js';\n</script>\n\n<p>User name: {userState.name}</p>\n<button onclick={() => {\n\tuserState.name = 'new name';\n}}>\n\tchange name\n</button>\n```\n\nStores remain a good solution for complex asynchronous data streams or when more manual control over value updates and change listening is needed. [cite: 466] They are also useful for those familiar with RxJs. [cite: 467]\n\n**`svelte/store` module**: This module provides functions for creating stores:\n* **`writable`**: Creates a store whose values can be set from outside components. [cite: 470] It includes `set` (to set a new value) and `update` (to update the value using a callback) methods. [cite: 471, 474] If a function is provided as a second argument, it's called when the subscriber count goes from zero to one, and it must return a `stop` function that is called when the count goes from one to zero. [cite: 477, 479] Writable values are lost on page refresh unless explicitly synced (e.g., to `localStorage`). [cite: 482, 483]\n* **`readable`**: Creates a store whose value cannot be set from outside. [cite: 484] Its second argument behaves like `writable`'s second argument. [cite: 484]\n* **`derived`**: Derives a store from one or more other stores. [cite: 487] The callback runs on initial subscription and whenever store dependencies change. [cite: 488] It can be synchronous or asynchronous (using `set` and `update` arguments in the callback). [cite: 492] A third argument can provide an initial value. [cite: 493]\n* **`readonly`**: Makes an existing store readonly. [cite: 506]\n* **`get`**: Retrieves the current value of a store without subscribing to it. [cite: 509, 511]"}